"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[5010],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return u}});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=p(n),u=l,h=m["".concat(s,".").concat(u)]||m[u]||d[u]||r;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function u(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,o=new Array(r);o[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:l,o[1]=i;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},85162:function(e,t,n){n.d(t,{Z:function(){return o}});var a=n(67294),l=n(34334),r="tabItem_Ymn6";function o(e){var t=e.children,n=e.hidden,o=e.className;return a.createElement("div",{role:"tabpanel",className:(0,l.Z)(r,o),hidden:n},t)}},65488:function(e,t,n){n.d(t,{Z:function(){return u}});var a=n(83117),l=n(67294),r=n(34334),o=n(72389),i=n(67392),s=n(7094),p=n(12466),c="tabList__CuJ",d="tabItem_LNqP";function m(e){var t,n,o=e.lazy,m=e.block,u=e.defaultValue,h=e.values,k=e.groupId,b=e.className,N=l.Children.map(e.children,(function(e){if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),_=null!=h?h:N.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),f=(0,i.l)(_,(function(e,t){return e.value===t.value}));if(f.length>0)throw new Error('Docusaurus error: Duplicate values "'+f.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var g=null===u?u:null!=(t=null!=u?u:null==(n=N.find((function(e){return e.props.default})))?void 0:n.props.value)?t:N[0].props.value;if(null!==g&&!_.some((function(e){return e.value===g})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+g+'" but none of its children has the corresponding value. Available values are: '+_.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var y=(0,s.U)(),T=y.tabGroupChoices,v=y.setTabGroupChoices,I=(0,l.useState)(g),O=I[0],w=I[1],E=[],j=(0,p.o5)().blockElementScrollPositionUntilNextRender;if(null!=k){var D=T[k];null!=D&&D!==O&&_.some((function(e){return e.value===D}))&&w(D)}var B=function(e){var t=e.currentTarget,n=E.indexOf(t),a=_[n].value;a!==O&&(j(t),w(a),null!=k&&v(k,String(a)))},C=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a,l=E.indexOf(e.currentTarget)+1;n=null!=(a=E[l])?a:E[0];break;case"ArrowLeft":var r,o=E.indexOf(e.currentTarget)-1;n=null!=(r=E[o])?r:E[E.length-1]}null==(t=n)||t.focus()};return l.createElement("div",{className:(0,r.Z)("tabs-container",c)},l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":m},b)},_.map((function(e){var t=e.value,n=e.label,o=e.attributes;return l.createElement("li",(0,a.Z)({role:"tab",tabIndex:O===t?0:-1,"aria-selected":O===t,key:t,ref:function(e){return E.push(e)},onKeyDown:C,onFocus:B,onClick:B},o,{className:(0,r.Z)("tabs__item",d,null==o?void 0:o.className,{"tabs__item--active":O===t})}),null!=n?n:t)}))),o?(0,l.cloneElement)(N.filter((function(e){return e.props.value===O}))[0],{className:"margin-top--md"}):l.createElement("div",{className:"margin-top--md"},N.map((function(e,t){return(0,l.cloneElement)(e,{key:t,hidden:e.props.value!==O})}))))}function u(e){var t=(0,o.Z)();return l.createElement(m,(0,a.Z)({key:String(t)},e))}},13701:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return c},default:function(){return k},frontMatter:function(){return p},metadata:function(){return d},toc:function(){return u}});var a=n(83117),l=n(80102),r=(n(67294),n(3905)),o=n(65488),i=n(85162),s=["components"],p={sidebar_position:4,title:"Object Fetcher"},c=void 0,d={unversionedId:"jimmer-sql/query/fetcher",id:"jimmer-sql/query/fetcher",title:"Object Fetcher",description:"Object Fetcher is a very powerful feature provided by jimmer-sql, comparable to GraphQL.",source:"@site/docs/jimmer-sql/query/fetcher.mdx",sourceDirName:"jimmer-sql/query",slug:"/jimmer-sql/query/fetcher",permalink:"/jimmer/docs/jimmer-sql/query/fetcher",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer/tree/main/doc/docs/jimmer-sql/query/fetcher.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Object Fetcher"},sidebar:"tutorialSidebar",previous:{title:"Selection",permalink:"/jimmer/docs/jimmer-sql/query/selection"},next:{title:"Simple Query",permalink:"/jimmer/docs/jimmer-sql/query/find"}},m={},u=[{value:"Scope of this article",id:"scope-of-this-article",level:2},{value:"Basic usage",id:"basic-usage",level:2},{value:"Fetch scalar property",id:"fetch-scalar-property",level:3},{value:"Fetch multiple properties",id:"fetch-multiple-properties",level:3},{value:"allScalarFields",id:"allscalarfields",level:3},{value:"Negative property",id:"negative-property",level:3},{value:"allTableFields",id:"alltablefields",level:3},{value:"Fetch associated object with only id.",id:"fetch-associated-object-with-only-id",level:3},{value:"BatchSize",id:"batchsize",level:3},{value:"Specify the properties of the associated objects",id:"specify-the-properties-of-the-associated-objects",level:3},{value:"Association-level pagination",id:"association-level-pagination",level:3},{value:"Field Filter",id:"field-filter",level:3},{value:"Recursively query self-associated properties",id:"recursively-query-self-associated-properties",level:2},{value:"Model and data preparation",id:"model-and-data-preparation",level:3},{value:"Limited depth",id:"limited-depth",level:3},{value:"Infinite recursion",id:"infinite-recursion",level:3},{value:"Developer controls whether each node is recursive",id:"developer-controls-whether-each-node-is-recursive",level:3},{value:"Compare with GraphQL",id:"compare-with-graphql",level:2}],h={toc:u};function k(e){var t=e.components,p=(0,l.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},h,p,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Object Fetcher is a very powerful feature provided by jimmer-sql, comparable to GraphQL."),(0,r.kt)("p",{parentName:"admonition"},"Even if users do not use any GraphQL-related technology stack, they can obtain object graph query capabilities similar to GraphQL at the SQL query level.")),(0,r.kt)("p",null,"Object fetcher is similar to the following techniques, but more powerful: "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.baeldung.com/jpa-entity-graph"},"EntityGraph of JPA")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://docs.microsoft.com/en-us/dotnet/api/system.data.objects.objectquery-1.include?view=netframework-4.8"},(0,r.kt)("inlineCode",{parentName:"a"},"Include")," of ADO.NET EntityFramework")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://guides.rubyonrails.org/active_record_querying.html#includes"},(0,r.kt)("inlineCode",{parentName:"a"},"include")," of ActiveRecord"))),(0,r.kt)("p",null,"While the code to return the entire object in a query is simple, the default object format often doesn't fit well with development needs."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Object properties that we don't need are loaded, which is a waste. This is called the ",(0,r.kt)("b",null,"over fetch")," problem."),(0,r.kt)("li",{parentName:"ol"},"The object properties we need have not been loaded so that the program cannot work normlly, this is called the ",(0,r.kt)("b",null,"under fetch")," problem.")),(0,r.kt)("p",null,"Object fetcher solve this problem nicely, make queries to return objects that are neither over fetched nor under fetched."),(0,r.kt)("p",null,"As returned results with object fetchers, dynamic objects can describe arbitrarily complex data structures, and you can decide whether each business perspective can protect certain entities, relationships, or even properties."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"shape",src:n(58793).Z,width:"1150",height:"856"})),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Please use a unified entity model to express the data format required by any business, instead of defining DTOs for the data format required by each business scenario")),(0,r.kt)("h2",{id:"scope-of-this-article"},"Scope of this article"),(0,r.kt)("p",null,"jimmer-sql can mount an external cache, whether using a cache or not will cause the object fetch to generate very different SQL."),(0,r.kt)("p",null,"Take the query ",(0,r.kt)("inlineCode",{parentName:"p"},"Book")," objects and their association collections ",(0,r.kt)("inlineCode",{parentName:"p"},"authors")," as an example:"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(\n        book.fetch(\n            BookFetcher.$\n                .allScalarFields()\n                .authors(\n                    AuthorFetcher.$\n                        .allScalarFields()\n                )\n        )\n    )\n    .execute();\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        select(\n            table.fetchBy {\n                allScalarFields()\n                authors {\n                    allScalarFields()\n                }\n            }\n        )\n    }\n    .execute()\n")))),(0,r.kt)("p",null,"Using a cache or not will cause the object fetcher to generate very different SQL."),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"non-cache",label:"SQL for non-cached mode",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"\n/* The main query itself */\nselect \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE, \n    tb_1_.STORE_ID \nfrom BOOK as tb_1_\n\n/* Query the associated object by association `Book.authors` */\nselect \n    tb_2_.BOOK_ID, \n\n    tb_1_.ID, \n    tb_1_.FIRST_NAME, \n    tb_1_.LAST_NAME, \n    tb_1_.GENDER \nfrom AUTHOR as tb_1_ \ninner join BOOK_AUTHOR_MAPPING as tb_2_ \n    on tb_1_.ID = tb_2_.AUTHOR_ID \nwhere tb_2_.BOOK_ID in (\n    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?\n)\n"))),(0,r.kt)(i.Z,{value:"cache",label:"SQL for cached mode",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"\n/* The main query itself */\nselect \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE, \n    tb_1_.STORE_ID \nfrom BOOK as tb_1_\n\n/*\n * Get the ids of the associated objects through \n * the association cache of `Book.authors`.\n *\n * If some associations do not exist in the cache, \n * query these associations, then write them to the association cache\n */\nselect \n    tb_1_.BOOK_ID, \n    tb_1_.AUTHOR_ID \nfrom BOOK_AUTHOR_MAPPING as tb_1_ \n    where tb_1_.BOOK_ID in (\n        ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?\n    )\n\n/*\n * Get the associated object from the object cache \n * through the id collection obtained in the previous step.\n *\n * If some associated objects do not exist in the object cache, \n * query these objects, then write them to the object cache\n */\nselect \n    tb_1_.ID, \n    tb_1_.FIRST_NAME, \n    tb_1_.LAST_NAME, \n    tb_1_.GENDER \nfrom AUTHOR as tb_1_ \nwhere tb_1_.ID in (?, ?, ?, ?, ?)\n")))),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Generating different SQL for different situations makes it difficult to discuss Object Fetcher in this article."),(0,r.kt)("p",{parentName:"admonition"},"Therefore, the SQL mentioned in the rest of this article is only for non-cached scenario.")),(0,r.kt)("h2",{id:"basic-usage"},"Basic usage"),(0,r.kt)("h3",{id:"fetch-scalar-property"},"Fetch scalar property"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(\n        // highlight-next-line\n        book.fetch(\n            BookFetcher.$.name()\n        )\n    )\n    .execute();\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"\nval books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            // highlight-next-line\n            table.fetchBy { \n                name()\n            }\n        )\n    }\n    .execute()\n\n")))),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The annotation processor will automatically generate a fetcher class for each entity interface, in this case, it is ",(0,r.kt)("inlineCode",{parentName:"p"},"BookFetcher"),".")),(0,r.kt)("p",null,"The generated SQL is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME \nfrom BOOK as tb_1_ \nwhere tb_1_.EDITION = ?\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The Java code does not call the method ",(0,r.kt)("inlineCode",{parentName:"p"},"id()")," in BookFetcher, however, we see that the SQL statement still queries the id property of the object."),(0,r.kt)("p",{parentName:"admonition"},"The id property is treated specially, is always queried, and is not controlled by the object fetcher."),(0,r.kt)("p",{parentName:"admonition"},"In fact, there is no method ",(0,r.kt)("inlineCode",{parentName:"p"},"id() ")," in the auto-generated class ",(0,r.kt)("inlineCode",{parentName:"p"},"BookFetcher")," because it is not needed.")),(0,r.kt)("p",null,"The printed result is as follows (the original output is compact, formatted here for readability):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{\n    "id":3,\n    "name":"Learning GraphQL"\n}\n...omit the 2nd object...,\n...omit the 3rd object...,\n...omit the 4th object...\n')),(0,r.kt)("h3",{id:"fetch-multiple-properties"},"Fetch multiple properties"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(\n        book.fetch(\n            // highlight-next-line\n            BookFetcher.$.name().price()\n        )\n    )\n    .execute();\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                name()\n                // highlight-next-line\n                price()\n            }\n        )\n    }\n    .execute()\n")))),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Object fetchers are immutable objects, and each call to chained method  returns a new object fetcher."),(0,r.kt)("p",{parentName:"admonition"},"That is, in the above ",(0,r.kt)("strong",{parentName:"p"},"Java")," code"),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"BookFetcher.$")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"BookFetcher.$.name()")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"BookFetcher.$.name().price()"))),(0,r.kt)("p",{parentName:"admonition"},"are three different object fetchers, all of them are immutable."),(0,r.kt)("p",{parentName:"admonition"},"Object fetcher is immutable object, so you can freely share object fetchers by static variables.")),(0,r.kt)("p",null,"The generated SQL is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME,\n    tb_1_.PRICE  \nfrom BOOK as tb_1_ \nwhere tb_1_.EDITION = ?\n")),(0,r.kt)("p",null,"The printed result is as follows (the original output is compact, formatted here for readability):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{\n    "id":3,\n    "name":"Learning GraphQL",\n    "price":51.00\n}\n...omit the 2nd object...,\n...omit the 3rd object...,\n...omit the 4th object...\n')),(0,r.kt)("h3",{id:"allscalarfields"},"allScalarFields"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(\n        book.fetch(\n            // highlight-next-line\n            BookFetcher.$.allScalarFields()\n        )\n    )\n    .execute();\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                // highlight-next-line\n                allScalarFields()\n            }\n        )\n    }\n    .execute()\n")))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"allScalarFields()")," is used to load all scalar fields."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Since objects in real projects tend to have many properties, ",(0,r.kt)("inlineCode",{parentName:"p"},"allScalarFields()")," is very useful.")),(0,r.kt)("p",null,"The generated SQL is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE   \nfrom BOOK as tb_1_ \nwhere tb_1_.EDITION = ?\n")),(0,r.kt)("p",null,"The printed result is as follows (the original output is compact, formatted here for readability):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{\n    "id":3,\n    "name":"Learning GraphQL",\n    "edition":3,\n    "price":51.00\n}\n...omit the 2nd object...,\n...omit the 3rd object...,\n...omit the 4th object...\n')),(0,r.kt)("h3",{id:"negative-property"},"Negative property"),(0,r.kt)("p",null,"The properties mentioned above are all positive properties, and properties to be queried are constantly added. Negative properties are the opposite, removing the specified property from the existing object fetcher."),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(\n        book.fetch(\n            BookFetcher.$\n            .allScalarFields()\n            // highlight-next-line\n            .edition(false)\n        )\n    )\n    .execute();\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                allScalarFields()\n                // highlight-next-line\n                edition(false)\n            }\n        )\n    }\n    .execute()\n")))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"edition(false)")," takes the parameter false, which is the negative property."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The properties of ",(0,r.kt)("inlineCode",{parentName:"li"},"allScalarFields()")," means ",(0,r.kt)("inlineCode",{parentName:"li"},"id + name + edition + price")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"edition(false)")," means ",(0,r.kt)("inlineCode",{parentName:"li"},"-edition"))),(0,r.kt)("p",null,"Finally, the merged properties are ",(0,r.kt)("inlineCode",{parentName:"p"},"id + name + price")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},"For positive properties, ",(0,r.kt)("inlineCode",{parentName:"li"},"edition()")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"edition(true)")," are equivalent."),(0,r.kt)("li",{parentName:"ol"},"Negative properties are very useful when most properties need to be fetched but a few properties need not be fetched."))),(0,r.kt)("p",null,"The generated SQL is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.PRICE   \nfrom BOOK as tb_1_ \nwhere tb_1_.EDITION = ?\n")),(0,r.kt)("p",null,"The printed result is as follows (the original output is compact, formatted here for readability):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{\n    "id":3,\n    "name":"Learning GraphQL",\n    "price":51.00\n}\n...omit the 2nd object...,\n...omit the 3rd object...,\n...omit the 4th object...\n')),(0,r.kt)("h3",{id:"alltablefields"},"allTableFields"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(\n        book.fetch(\n            // highlight-next-line\n            BookFetcher.$.allTableFields()\n        )\n    )\n    .execute();\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                // highlight-next-line\n                allTableFields()\n            }\n        )\n    }\n    .execute()\n")))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"allTableFields()")," contains all the properties declared by the entity interface, including scalar properties, and many-to-one properties based on foreign keys (of course, the parent object only has id)."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"In the case where the associated object does not use ",(0,r.kt)("a",{parentName:"strong",href:"../advanced/filter"},"global filter")),",",(0,r.kt)("inlineCode",{parentName:"p"},"allTableFields()")," returns the default object format, so the following two examples are equivalent")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java"},"select(\n    book.fetch(\n        BookFetcher.$.allTableFields()\n    )\n)\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"select(\n    table.fetchBy(\n        allTableFields()\n    )\n)\n"))))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java"},"select(book)\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"select(table)\n")))))),(0,r.kt)("p",null,"The generated SQL is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE, \n    tb_1_.STORE_ID \nfrom BOOK as tb_1_ \nwhere tb_1_.EDITION = ?\n")),(0,r.kt)("p",null,"The printed result is as follows (the original output is compact, formatted here for readability):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{\n    "id":3,\n    "name":\n    "Learning GraphQL",\n    "edition":3,\n    "price":51.00,\n    "store":{"id":"d38c10da-6be8-4924-b9b9-5e81899612a0"}\n}\n...omit the 2nd object...,\n...omit the 3rd object...,\n...omit the 4th object...\n')),(0,r.kt)("p",null,"Like the default object format, many-to-one properties based on foreign key are set to the parent object with only the id property."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"If the associated object uses ",(0,r.kt)("a",{parentName:"p",href:"../advanced/filter"},"global filter"),", these two ways are no longer equivalent."),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Querying simple table objects: ",(0,r.kt)("a",{parentName:"p",href:"../advanced/filter"},"global filter")," will not be applied, as long as the foreign key is not null, the association property will be set to the parent object with only id.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"allScalarFields()"),": ",(0,r.kt)("a",{parentName:"p",href:"../advanced/filter"},"global filter")," will be applied, even if the foreign key is not null, the parent object may be set to null because the associated object does not meet the filtering rules.")))),(0,r.kt)("h3",{id:"fetch-associated-object-with-only-id"},"Fetch associated object with only id."),(0,r.kt)("p",null,"We have already explained how to implement this function for foreign key based associations, so let's look at an example of ",(0,r.kt)("inlineCode",{parentName:"p"},"Book.authors")," for many-to-many associations."),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(\n        book.fetch(\n            BookFetcher.$.\n                .allScalarFields()\n                // highlight-next-line\n                .authors()\n        )\n    )\n    .execute();\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                allScalarFields()\n                // highlight-next-line\n                authors()\n            }\n        )\n    }\n    .execute()\n")))),(0,r.kt)("p",null,"Here, ",(0,r.kt)("inlineCode",{parentName:"p"},"authors")," means to fetch many-to-many associations. Note that no parameters are specified, which means that only the id property of the associated object is fetched."),(0,r.kt)("p",null,"Two SQL statemenets are generated."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Query the aggregate root objects: ",(0,r.kt)("inlineCode",{parentName:"p"},"Book")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE, \n    tb_1_.STORE_ID \nfrom BOOK as tb_1_ \nwhere tb_1_.EDITION = ?\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Query all ",(0,r.kt)("inlineCode",{parentName:"p"},"Author")," objects with only id based on association ",(0,r.kt)("inlineCode",{parentName:"p"},"Book.authors")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.BOOK_ID, /* batch-map key */\n    tb_1_.AUTHOR_ID /* batch-map value */\nfrom BOOK_AUTHOR_MAPPING as tb_1_ \n    where tb_1_.BOOK_ID in (?, ?, ?, ?)\n")))),(0,r.kt)("p",null,"This example illustrates:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The current query only needs the id of the associated object, and no filter is used (filter is a concept that will be explained later)."),(0,r.kt)("p",{parentName:"li"},"jimmer-sql will optimize this situation by querying only the middle table ",(0,r.kt)("inlineCode",{parentName:"p"},"BOOK_AUTHOR_MAPPING"),", not the target table ",(0,r.kt)("inlineCode",{parentName:"p"},"AUTHOR"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"where tb_1_.BOOK_ID in (?, ?, ?, ?)")," is a batch query, because the first SQL statement returns 4 aggregate root objects."),(0,r.kt)("p",{parentName:"li"},"jimmer-sql uses batch queries to solve the ",(0,r.kt)("inlineCode",{parentName:"p"},"N+1")," problem, just like GraphQL's ",(0,r.kt)("inlineCode",{parentName:"p"},"DataLoader"),"."),(0,r.kt)("p",{parentName:"li"},"When the list of a batch is too long, jimmer-sql will cut it in batches, which will be explained in the ",(0,r.kt)("a",{parentName:"p",href:"#batchsize"},"Batch Size section")," later.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"jimmer-sql uses additional SQL to query associated objects instead of using LEFT JOIN in the SQL of the primary data query."),(0,r.kt)("p",{parentName:"li"},"The purpose of this design is to prevent the JOIN of the collection association from causing duplication of results, because this kind of data duplication has a devastating effect on pagination queries."))),(0,r.kt)("p",null,"The printed result is as follows (the original output is compact, formatted here for readability):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{\n    "id":3,\n    "name":"Learning GraphQL",\n    "edition":3,\n    "price":51.00,\n    "authors":[\n        {"id":2},\n        {"id":"fd6bb6cf-336d-416c-8005-1ae11a6694b5"}\n    ]\n}\n...omit the 2nd object...,\n...omit the 3rd object...,\n...omit the 4th object...\n')),(0,r.kt)("h3",{id:"batchsize"},"BatchSize"),(0,r.kt)("p",null,"In the above example, we see SQL like this"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.BOOK_ID, \n    tb_1_.AUTHOR_ID \nfrom BOOK_AUTHOR_MAPPING as tb_1_ \n    where tb_1_.BOOK_ID in (?, ?, ?, ?)\n")),(0,r.kt)("p",null,"Here, the ",(0,r.kt)("inlineCode",{parentName:"p"},"in")," expression implements a batch query, solving the ",(0,r.kt)("inlineCode",{parentName:"p"},"N+1")," problem."),(0,r.kt)("p",null,"If a batch is too large, it will be divided into several batches according to a setting called ",(0,r.kt)("inlineCode",{parentName:"p"},"batchSize"),", such as"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(\n        book.fetch(\n            BookFetcher.$\n                .authors(\n                    AuthorFetcher.$,\n                    // highlight-next-line\n                    it -> it.batch(2)\n                )\n        )\n    )\n    .execute();\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                allScalarFields()\n                authors({\n                    // highlight-next-line\n                    batch(2)\n                }) {}\n            }\n        )\n    }\n    .execute()\n")))),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"Here, the batchSize of the association ",(0,r.kt)("inlineCode",{parentName:"p"},"Book.authors")," is set to 2. This configuration will lead to poor performance. This is just for demonstration, please do not set such a small value in actual projects.")),(0,r.kt)("p",null,"This will cause ",(0,r.kt)("inlineCode",{parentName:"p"},"in(?, ?, ?, ?)")," clause to be split into two ",(0,r.kt)("inlineCode",{parentName:"p"},"in(?, ?)")," clauses, and the SQL that fetches the associated objects will be split into two pieces."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.BOOK_ID, \n    tb_1_.AUTHOR_ID \nfrom BOOK_AUTHOR_MAPPING as tb_1_ \n    where tb_1_.BOOK_ID in (?, ?)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.BOOK_ID, \n    tb_1_.AUTHOR_ID \nfrom BOOK_AUTHOR_MAPPING as tb_1_ \n    where tb_1_.BOOK_ID in (?, ?)\n")))),(0,r.kt)("p",null,"In actual development, batchSize is not set like this in most cases, but the global configuration in JSqlClient is used."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"JSqlClient.getDefaultBatchSize()"),": Default batchSize for one-to-one and many-to-one association properties, default value is 128"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"JSqlClient.getDefaultListBatchSize()"),": Default batchSize for one-to-many and many-to-many association properties, default value is 16")),(0,r.kt)("p",null,"When creating a JSqlClient, you can change the global configuration:"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"JSqlClient sqlClient = JSqlClient\n    .newBuilder()\n    .setDefaultBatchSize(256)\n    .setDefaultListBatchSize(32)\n    ....\n    build();\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val sqlClient = newKSqlClient {\n    setDefaultBatchSize(256)\n    setDefaultListBatchSize(32)\n    ....\n}\n")))),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Neither the object fetcher level ",(0,r.kt)("inlineCode",{parentName:"p"},"batch Size")," nor the global level ",(0,r.kt)("inlineCode",{parentName:"p"},"batch Size")," should exceed 1000, because ",(0,r.kt)("inlineCode",{parentName:"p"},"in(...)")," in Oracle database allows up to 1000 values.")),(0,r.kt)("h3",{id:"specify-the-properties-of-the-associated-objects"},"Specify the properties of the associated objects"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(\n        book.fetch(\n            BookFetcher.$.\n                .allScalarFields()\n                .store(\n                    BookStoreFetcher.$\n                        // highlight-next-line\n                        .allScalarFields()\n                )\n                .authors(\n                    AuthorFetcher.$\n                        // highlight-next-line\n                        .allScalarFields()\n                )\n        )\n    )\n    .execute();\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                allScalarFields()\n                store { \n                    // highlight-next-line\n                    allScalarFields()\n                }\n                authors { \n                    // highlight-next-line\n                    allScalarFields()\n                }\n            }\n        )\n    }\n    .execute()\n")))),(0,r.kt)("p",null,"In this query, we fetch both ",(0,r.kt)("inlineCode",{parentName:"p"},"Book.store")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Book.authors"),", and further fetch all scalar properties of ",(0,r.kt)("inlineCode",{parentName:"p"},"BookStore")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Author"),"."),(0,r.kt)("p",null,"Finally, three SQL statements are generated."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Query the aggregate root objects: ",(0,r.kt)("inlineCode",{parentName:"p"},"Book")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE, \n    tb_1_.STORE_ID \nfrom BOOK as tb_1_ \nwhere tb_1_.EDITION = ?\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Query the associated ",(0,r.kt)("inlineCode",{parentName:"p"},"BookStore")," objects"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.WEBSITE \nfrom BOOK_STORE as tb_1_ \nwhere \n    tb_1_.ID in (?, ?)\n/* \n * There are 4 main objects, and there are\n * 2 foreign keys after deduplication \n */\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Query the associated ",(0,r.kt)("inlineCode",{parentName:"p"},"Author")," objects"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    \n    /* batch-map key */\n    tb_1_.BOOK_ID, \n\n    /* batch-map value */\n    tb_1_.AUTHOR_ID, \n    tb_3_.FIRST_NAME, \n    tb_3_.LAST_NAME, \n    tb_3_.GENDER\n\nfrom BOOK_AUTHOR_MAPPING as tb_1_ \ninner join AUTHOR as tb_3_ \n    on tb_1_.AUTHOR_ID = tb_3_.ID \nwhere \n    tb_1_.BOOK_ID in (?, ?, ?, ?)\n")))),(0,r.kt)("p",null,"The printed result is as follows (the original output is compact, formatted here for readability):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{\n    "id":3,\n    "name":"Learning GraphQL",\n    "edition":3,\n    "price":51.00,\n    "store":{\n        "id":1,\n        "name":"O\'REILLY",\n        "website":null\n    },\n    "authors":[\n        {\n            "id":2,\n            "firstName":"Alex",\n            "lastName":"Banks",\n            "gender":"MALE"\n        },{\n            "id":1,\n            "firstName":"Eve",\n            "lastName":"Procello",\n            "gender":"MALE"\n        }\n    ]\n},\n...omit the 2nd object...,\n...omit the 3rd object...,\n...omit the 4th object...\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"From this example, we can see that the object fetcher is a tree, so there is no limit to the fetching depth of the associated objects.")),(0,r.kt)("h3",{id:"association-level-pagination"},"Association-level pagination"),(0,r.kt)("p",null,"For collection association property, ",(0,r.kt)("inlineCode",{parentName:"p"},"limit(limit, offset)")," can be specified when fetch property, this is pagination at the association level"),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Associative-level pagination and batch loading cannot coexist, therefore, associative-level pagination will inevitably lead to the ",(0,r.kt)("inlineCode",{parentName:"p"},"N+1")," problem, please use this feature with caution!"),(0,r.kt)("p",{parentName:"admonition"},"If associative-level pagination is used, ",(0,r.kt)("inlineCode",{parentName:"p"},"batchSize")," must be specified as 1, otherwise it will cause an exception. The purpose of this design is to make it clear to developers and code reviewers that the current code has ",(0,r.kt)("inlineCode",{parentName:"p"},"N+1")," performance risks.")),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(\n        book.fetch(\n            BookFetcher.$\n                .allScalarFields()\n                .authors(\n                    AuthorFetcher.$.allScalarFields(),\n                    // highlight-next-line\n                    it -> it.batch(1).limit(10, 90)\n                )\n        )\n    )\n    .execute();\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            // highlight-next-line\n            table.fetchBy {\n                allScalarFields()\n                authors({\n                    batch(1)\n                    // highlight-next-line\n                    limit(90, 10)\n                }) {\n                    allScalarFields()\n                }\n            }\n        )\n    }\n    .execute()\n")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Because the associated pagination cannot solve the ",(0,r.kt)("inlineCode",{parentName:"li"},"N + 1")," problem, more SQL is generated"),(0,r.kt)("li",{parentName:"ul"},"Due to different pagination ways in different databases, in order to simplify the discussion, it is assumed that the dialect uses ",(0,r.kt)("inlineCode",{parentName:"li"},"H2Dialect"))),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Query the aggregate root objects: ",(0,r.kt)("inlineCode",{parentName:"p"},"Book")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE \nfrom BOOK as tb_1_ \nwhere tb_1_.EDITION = ?\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Pagination query for the assciated object referenced by the property ",(0,r.kt)("inlineCode",{parentName:"p"},"Book.authors")," of 1st ",(0,r.kt)("inlineCode",{parentName:"p"},"Book")," object"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.AUTHOR_ID, \n    tb_3_.FIRST_NAME, \n    tb_3_.LAST_NAME, \n    tb_3_.GENDER \nfrom BOOK_AUTHOR_MAPPING as tb_1_ \ninner join AUTHOR as tb_3_ \n    on tb_1_.AUTHOR_ID = tb_3_.ID \nwhere tb_1_.BOOK_ID = ?\n/* highlight-next-line */ \nlimit ? offset ?\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Pagination query for the assciated object referenced by the property ",(0,r.kt)("inlineCode",{parentName:"p"},"Book.authors")," of 2nd ",(0,r.kt)("inlineCode",{parentName:"p"},"Book")," object"),(0,r.kt)("p",{parentName:"li"},"Same as above, slightly")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Pagination query for the assciated object referenced by the property ",(0,r.kt)("inlineCode",{parentName:"p"},"Book.authors")," of 3rd ",(0,r.kt)("inlineCode",{parentName:"p"},"Book")," object"),(0,r.kt)("p",{parentName:"li"},"Same as above, slightly")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Pagination query for the assciated object referenced by the property ",(0,r.kt)("inlineCode",{parentName:"p"},"Book.authors")," of 4th ",(0,r.kt)("inlineCode",{parentName:"p"},"Book")," object"),(0,r.kt)("p",{parentName:"li"},"Same as above, slightly"))),(0,r.kt)("h3",{id:"field-filter"},"Field Filter"),(0,r.kt)("p",null,"When fetching association properties, you can specify filter to specify filter conditions for association objects."),(0,r.kt)("p",null,"Here, for comparison, we let the query select two columns, both of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Book"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Apply filter to the association ",(0,r.kt)("inlineCode",{parentName:"li"},"Book.authors")," of the objects of first column."),(0,r.kt)("li",{parentName:"ul"},"No filter to the association ",(0,r.kt)("inlineCode",{parentName:"li"},"Book.authors")," of the objects of second column.")),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(\n        \n        // First column\n        book.fetch(\n            BookFetcher.$\n                .allScalarFields()\n                .authors(\n                    AuthorFetcher.$\n                        .allScalarFields(),\n\n                    // Use filter here\n                    // highlight-next-line\n                    it -> it.filter(args -> {\n                        args.where(\n                            args.getTable()\n                                .firstName().ilike("a")\n                        );\n                    })\n                )\n        ),\n\n        // Second column\n        book.fetch(\n            BookFetcher.$\n                .allScalarFields()\n                .authors(\n                    AuthorFetcher.$\n                            .allScalarFields()\n\n                    // No filter here\n                )\n        )\n    )\n    .execute();\n'))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val tuples: List<Tuple2<Book, Book>> = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n\n            // First column\n            table.fetchBy {\n                allScalarFields()\n                authors({\n                    // Use filter here\n                    // highlight-next-line\n                    filter {\n                        where(table.firstName ilike "a")\n                    }\n                }) {\n                    allScalarFields()\n                }\n            },\n\n            // Second column\n            table.fetchBy {\n                allScalarFields()\n                authors { // No filter here\n                    allScalarFields()\n                }\n            }\n        )\n    }\n    .execute()\n')))),(0,r.kt)("p",null,"Three SQL statements are generated."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Select the aggregate root, a tuple list, each Tuple consists of two ",(0,r.kt)("inlineCode",{parentName:"p"},"Book")," objects."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select\n\n    /* For tuple._1 */\n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE, \n\n    /* For tuple._2 */\n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE \n\nfrom BOOK as tb_1_ \nwhere tb_1_.EDITION = ?\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Query the association property ",(0,r.kt)("inlineCode",{parentName:"p"}," Book.authors")," for the 4 ",(0,r.kt)("inlineCode",{parentName:"p"},"Book")," objects in column 1, using a filter."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    \n    tb_1_.BOOK_ID, \n\n    tb_1_.AUTHOR_ID, \n    tb_3_.FIRST_NAME, \n    tb_3_.LAST_NAME, \n    tb_3_.GENDER \nfrom BOOK_AUTHOR_MAPPING as tb_1_ \ninner join AUTHOR as tb_3_ \n    on tb_1_.AUTHOR_ID = tb_3_.ID \nwhere \n    tb_1_.BOOK_ID in (?, ?, ?, ?) \nand \n    /* Use filter here */\n    /* highlight-next-line */\n    lower(tb_3_.FIRST_NAME) like ?\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Query the association property ",(0,r.kt)("inlineCode",{parentName:"p"}," Book.authors")," for the 4 ",(0,r.kt)("inlineCode",{parentName:"p"},"Book")," objects in column 2, without filter."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    \n    tb_1_.BOOK_ID, \n\n    tb_1_.AUTHOR_ID, \n    tb_3_.FIRST_NAME, \n    tb_3_.LAST_NAME, \n    tb_3_.GENDER \nfrom BOOK_AUTHOR_MAPPING as tb_1_ \ninner join AUTHOR as tb_3_ \n    on tb_1_.AUTHOR_ID = tb_3_.ID \nwhere \n    tb_1_.BOOK_ID in (?, ?, ?, ?) \n/* No filter here */\n")))),(0,r.kt)("p",null,"The printed result is as follows (the original output is compact, formatted here for readability):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Tuple2{\n    _1={\n        "id":3,\n        "name":"Learning GraphQL",\n        "edition":3,\n        "price":51.00,\n        "authors":[\n            {\n                "id":2,\n                "firstName":"Alex",\n                "lastName":"Banks",\n                "gender":"MALE"\n            }\n        ]\n    }, \n    _2={\n        "id":3,\n        "name":"Learning GraphQL",\n        "edition":3,\n        "price":51.00,\n        "authors":[\n            {\n                "id":2,\n                "firstName":"Alex",\n                "lastName":"Banks",\n                "gender":"MALE"\n            },{\n                "id":"fd6bb6cf-336d-416c-8005-1ae11a6694b5",\n                "firstName":"Eve",\n                "lastName":"Procello",\n                "gender":"MALE"\n            }\n        ]\n    }\n}\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Filters can not only filter associated objects, but also sort associated objects. The principle is similar, and this article does not demonstrate.")),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"  For an associated property that satisfies both of the following conditions"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"is many-to-one association"),(0,r.kt)("li",{parentName:"ul"},"is non-null\nApplying a filter results in an exception"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"When a field-level filter is used, the ",(0,r.kt)("a",{parentName:"p",href:"../advanced/cache"},"external cache")," of the field will be ignored."),(0,r.kt)("p",{parentName:"li"},"If you want to use association cache, you can use ",(0,r.kt)("a",{parentName:"p",href:"../advanced/filter/#filters-and-caching"},"cache-friendly global filter"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"There is a common mistake in actual development (take Java as an example)"),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},'filter(it -> args.getTable().firstName().ilike "a")'),"."),(0,r.kt)("p",{parentName:"li"},"This code creates the conditional expression, but does not call ",(0,r.kt)("inlineCode",{parentName:"p"},"args.where"),". Filter code that neither calls ",(0,r.kt)("inlineCode",{parentName:"p"},"args.where")," nor ",(0,r.kt)("inlineCode",{parentName:"p"},"args.orderBy")," makes no sense."),(0,r.kt)("p",{parentName:"li"},"The correct code is"),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},'filter(it -> args.where(args.getTable().firstName().ilike "a"))'),".")))),(0,r.kt)("h2",{id:"recursively-query-self-associated-properties"},"Recursively query self-associated properties"),(0,r.kt)("p",null,"There is a common scenario: self-association."),(0,r.kt)("p",null,"From a database perspective, a self-association means that a table's foreign key refers to itself; from an object model's perspective, a self-association means a tree."),(0,r.kt)("p",null,"The difficulty of self-association is that the depth of the object cannot be controlled. In theory, it can be infinitely deep. For this, jimmer-sql provides good support."),(0,r.kt)("h3",{id:"model-and-data-preparation"},"Model and data preparation"),(0,r.kt)("p",null,"Define entity interface"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@Entity\npublic interface TreeNode {\n\n    @Id\n    @Column(name = "NODE_ID")\n    long id();\n\n    String name();\n\n    @Null\n    @ManyToOne\n    TreeNode parent();\n\n    @OneToMany(mappedBy = "parent")\n    List<TreeNode> childNodes();\n}\n'))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'@Entity\ninterface TreeNode {\n\n    @Id\n    @Column(name = "NODE_ID")\n    val id: Long\n\n    val name: String\n\n    @ManyToOne\n    val parent: TreeNode?\n\n    @OneToMany(mappedBy = "parent")\n    val childNodes: List<TreeNode>\n}\n')))),(0,r.kt)("p",null,"Prepare the database"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"create table tree_node(\n    node_id bigint not null,\n    name varchar(20) not null,\n    parent_id bigint\n);\nalter table tree_node\n    add constraint pk_tree_node\n        primary key(node_id);\nalter table tree_node\n    add constraint uq_tree_node\n        unique(parent_id, name);\nalter table tree_node\n    add constraint fk_tree_node__parent\n        foreign key(parent_id)\n            references tree_node(node_id);\n\ninsert into tree_node(\n    node_id, name, parent_id\n) values\n    (1, 'Home', null),\n        (2, 'Food', 1),\n            (3, 'Drinks', 2),\n                (4, 'Coca Cola', 3),\n                (5, 'Fanta', 3),\n            (6, 'Bread', 2),\n                (7, 'Baguette', 6),\n                (8, 'Ciabatta', 6),\n        (9, 'Clothing', 1),\n            (10, 'Woman', 9),\n                (11, 'Casual wear', 10),\n                    (12, 'Dress', 11),\n                    (13, 'Miniskirt', 11),\n                    (14, 'Jeans', 11),\n                (15, 'Formal wear', 10),\n                    (16, 'Suit', 15),\n                    (17, 'Shirt', 15),\n            (18, 'Man', 9),\n                (19, 'Casual wear', 18),\n                    (20, 'Jacket', 19),\n                    (21, 'Jeans', 19),\n                (22, 'Formal wear', 18),\n                    (23, 'Suit', 22),\n                    (24, 'Shirt', 22)\n;\n")),(0,r.kt)("h3",{id:"limited-depth"},"Limited depth"),(0,r.kt)("p",null,"Top down, fetch two layers"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"TreeNodeTable node = TreeNodeTable.$;\n\nList<TreeNode> treeNodes = sqlClient\n    .createQuery(node)\n    .where(node.parent().isNull())\n    .select(\n        node.fetch(\n            TreeNodeFetcher.$\n                .name()\n                .childNodes(\n                    TreeNodeFetcher.$.name(),\n                    // highlight-next-line\n                    it -> it.depth(2)\n                )\n        )\n    )\n    .execute();\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val treeNodes = sqlClient\n    .createQuery(TreeNode::class) {\n        where(table.parent.isNull())\n        select(\n            table.fetchBy {\n                allScalarFields()\n                childNodes({\n                    // highlight-next-line\n                    depth(2)\n                }) { \n                    allScalarFields()\n                }\n            }\n        )\n    }\n    .execute()\n")))),(0,r.kt)("p",null,"Three SQL statements are generated."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Get the root nodes (layer 0)"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.NODE_ID, \n    tb_1_.NAME \nfrom TREE_NODE as tb_1_ \nwhere \n    tb_1_.PARENT_ID is null\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Fetch layer 1"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    \n    tb_1_.PARENT_ID,\n\n    tb_1_.NODE_ID, \n    tb_1_.NAME\n\nfrom TREE_NODE as tb_1_ \nwhere \n    tb_1_.PARENT_ID in (?)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Fetch layer 2"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.PARENT_ID, \n    tb_1_.NODE_ID, \n    tb_1_.NAME \nfrom TREE_NODE as tb_1_ \nwhere \n    tb_1_.PARENT_ID in (?, ?)\n")))),(0,r.kt)("p",null,"The printed result is as follows (the original output is compact, formatted here for readability):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "id":1,\n    "name":"Home",\n    "childNodes":[\n        {\n            "id":9,\n            "name":"Clothing",\n            "childNodes":[\n                {"id":18,"name":"Man"},\n                {"id":10,"name":"Woman"}\n            ]\n        },{\n            "id":2,\n            "name":"Food",\n            "childNodes":[\n                {"id":6,"name":"Bread"},\n                {"id":3,"name":"Drinks"}\n            ]\n        }\n    ]\n}\n')),(0,r.kt)("h3",{id:"infinite-recursion"},"Infinite recursion"),(0,r.kt)("p",null,"Top-down, fetch infinite layers"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"TreeNodeTable node = TreeNodeTable.$;\n\nList<TreeNode> treeNodes = sqlClient\n    .createQuery(node)\n    .where(node.parent().isNull())\n    .select(\n        node.fetch(\n            TreeNodeFetcher.$\n                .name()\n                .childNodes(\n                    TreeNodeFetcher.$.name(),\n                    // highlight-next-line\n                    it -> it.recursive()\n                )\n        )\n    )\n    .execute();\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val treeNodes = sqlClient\n    .createQuery(TreeNode::class) {\n        where(table.parent.isNull())\n        select(\n            table.fetchBy {\n                allScalarFields()\n                childNodes({\n                    // highlight-next-line\n                    recursive()\n                }) {\n                    allScalarFields()\n                }\n            }\n        )\n    }\n    .execute()\n")))),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"In the above code, ",(0,r.kt)("inlineCode",{parentName:"p"},"it.recursive()")," can also be written as ",(0,r.kt)("inlineCode",{parentName:"p"},"it.depth(Integer.MAX_VALUE)"),", the two are completely equivalent")),(0,r.kt)("p",null,"Six SQL statements are generated."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Get the root nodes (layer 0)"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.NODE_ID, \n    tb_1_.NAME \nfrom TREE_NODE as tb_1_ \nwhere \n    tb_1_.PARENT_ID is null\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Fetcher layer 1"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    \n    tb_1_.PARENT_ID,\n\n    tb_1_.NODE_ID, \n    tb_1_.NAME\n\nfrom TREE_NODE as tb_1_ \nwhere \n    tb_1_.PARENT_ID in (?)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Fetcher layer 2"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.PARENT_ID, \n    tb_1_.NODE_ID, \n    tb_1_.NAME \nfrom TREE_NODE as tb_1_ \nwhere \n    tb_1_.PARENT_ID in (?, ?)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Fetcher layer 3"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.PARENT_ID, \n    tb_1_.NODE_ID, \n    tb_1_.NAME \nfrom TREE_NODE as tb_1_ \nwhere \n    tb_1_.PARENT_ID in (?, ?, ?, ?)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Fetcher layer 4"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.PARENT_ID, \n    tb_1_.NODE_ID, \n    tb_1_.NAME \nfrom TREE_NODE as tb_1_ \nwhere \n    tb_1_.PARENT_ID in (?, ?, ?, ?, ?, ?, ?, ?)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Fetcher layer 5"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"```sql\nselect \n    tb_1_.PARENT_ID, \n    tb_1_.NODE_ID, \n    tb_1_.NAME \nfrom TREE_NODE as tb_1_ \nwhere \n    tb_1_.PARENT_ID in (?, ?, ?, ?, ?, ?, ?, ?, ?)\n```\n")),(0,r.kt)("p",{parentName:"li"},"The printed result is as follows (the original output is compact, formatted here for readability):"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "id":1,"name":\n    "Home","childNodes":[\n        {\n            "id":9,\n            "name":"Clothing",\n            "childNodes":[\n                {\n                    "id":18,\n                    "name":"Man",\n                    "childNodes":[\n                        {\n                            "id":19,\n                            "name":"Casual wear",\n                            "childNodes":[\n                                {"id":20,"name":"Jacket","childNodes":[]},\n                                {"id":21,"name":"Jeans","childNodes":[]}\n                            ]\n                        },{\n                            "id":22,\n                            "name":"Formal wear",\n                            "childNodes":[\n                                {"id":24,"name":"Shirt","childNodes":[]},\n                                {"id":23,"name":"Suit","childNodes":[]}\n                            ]\n                        }\n                    ]\n                },{\n                    "id":10,\n                    "name":"Woman",\n                    "childNodes":[\n                        {\n                            "id":11,\n                            "name":"Casual wear",\n                            "childNodes":[\n                                {"id":12,"name":"Dress","childNodes":[]},\n                                {"id":14,"name":"Jeans","childNodes":[]},\n                                {"id":13,"name":"Miniskirt","childNodes":[]}\n                            ]\n                        },{\n                            "id":15,\n                            "name":"Formal wear",\n                            "childNodes":[\n                                {"id":17,"name":"Shirt","childNodes":[]},\n                                {"id":16,"name":"Suit","childNodes":[]}\n                            ]\n                        }\n                    ]\n                }\n            ]\n        },{\n            "id":2,\n            "name":"Food",\n            "childNodes":[\n                {\n                    "id":6,\n                    "name":"Bread",\n                    "childNodes":[\n                        {"id":7,"name":"Baguette","childNodes":[]},\n                        {"id":8,"name":"Ciabatta","childNodes":[]}\n                    ]\n                },{\n                    "id":3,\n                    "name":"Drinks",\n                    "childNodes":[\n                        {"id":4,"name":"Coca Cola","childNodes":[]},\n                        {"id":5,"name":"Fanta","childNodes":[]}\n                    ]\n                }\n            ]\n        }\n    ]\n}\n')),(0,r.kt)("h3",{id:"developer-controls-whether-each-node-is-recursive"},"Developer controls whether each node is recursive"),(0,r.kt)("p",null,'From top to bottom, fetch infinite layers. However, for nodes with the name "Clothing", skip recursion'),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'TreeNodeTable node = TreeNodeTable.$;\n\nList<TreeNode> treeNodes = sqlClient\n    .createQuery(node)\n    .where(node.parent().isNull())\n    .select(\n        node.fetch(\n            TreeNodeFetcher.$\n                .name()\n                .childNodes(\n                    TreeNodeFetcher.$.name(),\n                    it -> it.recursive(args ->\n                        // highlight-next-line\n                        !args.getEntity().name().equals("Clothing")\n                    )\n                )\n        )\n    )\n    .execute();\n'))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val treeNodes = sqlClient\n    .createQuery(TreeNode::class) {\n        where(table.parent.isNull())\n        select(\n            \n            table.fetchBy {\n                allScalarFields()\n                childNodes({\n                    recursive {\n                        // highlight-next-line\n                        entity.name != "Clothing"\n                    }\n                }) {\n                    allScalarFields()\n                }\n            }\n        )\n    }\n    .execute()\n')))),(0,r.kt)("p",null,"In the above code, the parameter of ",(0,r.kt)("inlineCode",{parentName:"p"},"it.recursive(args)")," is a lambda expression, and its parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"args")," is an object that provides two methods"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"args.getEntity()"),": The current node object."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"args.getDepth()"),": current node depth. It is 0 for nodes obtained directly through the primary query, and it increases as the recursion goes deeper."),(0,r.kt)("li",{parentName:"ol"},"User-determined return value: a boolean variable that determines whether to recursively fetch the current node.")),(0,r.kt)("p",null,"The meaning of the above code is that, except for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Clothing")," node, the rest of the sections will be recursively fetched."),(0,r.kt)("p",null,"Five SQL statements are generated."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Get the root nodes (layer 0)"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.NODE_ID, \n    tb_1_.NAME \nfrom TREE_NODE as tb_1_ \nwhere tb_1_.PARENT_ID is null\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Fetch layer 1"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n\n    tb_1_.PARENT_ID, \n    \n    tb_1_.NODE_ID, \n    tb_1_.NAME \n\nfrom TREE_NODE as tb_1_ \nwhere \n    tb_1_.PARENT_ID in (?)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Fetch layer 2"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'select \n\n    tb_1_.PARENT_ID, \n    \n    tb_1_.NODE_ID, \n    tb_1_.NAME \n\nfrom TREE_NODE as tb_1_ \nwhere \n    /* \n     * Home node has two child nodes:\n     *      "Food" and "Clothing",\n     * \n     * However, "Clothing is excluded by user,\n     * so `in(?)` is used here, not `in(?, ?)`\n     */\n    tb_1_.PARENT_ID in (?)\n'))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Fetch layer 3"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n\n    tb_1_.PARENT_ID, \n    \n    tb_1_.NODE_ID, \n    tb_1_.NAME \n\nfrom TREE_NODE as tb_1_ \nwhere \n    tb_1_.PARENT_ID in (?, ?)\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Fetch layer 4"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n\n    tb_1_.PARENT_ID, \n    \n    tb_1_.NODE_ID, \n    tb_1_.NAME \n\nfrom TREE_NODE as tb_1_ \nwhere \n    tb_1_.PARENT_ID in (?, ?, ?, ?)\n")))),(0,r.kt)("p",null,"The printed result is as follows (the original output is compact, formatted here for readability):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "id":1,\n    "name":"Home",\n    "childNodes":[\n        // highlight-next-line\n        {"id":9,"name":"Clothing"},\n        {\n            "id":2,\n            "name":"Food",\n            "childNodes":[\n                {\n                    "id":6,\n                    "name":"Bread",\n                    "childNodes":[\n                        {"id":7,"name":"Baguette","childNodes":[]},\n                        {"id":8,"name":"Ciabatta","childNodes":[]}\n                    ]\n                },{\n                    "id":3,\n                    "name":"Drinks",\n                    "childNodes":[\n                        {"id":4,"name":"Coca Cola","childNodes":[]},\n                        {"id":5,"name":"Fanta","childNodes":[]}\n                    ]\n                }\n            ]\n        }\n    ]\n}\n')),(0,r.kt)("h2",{id:"compare-with-graphql"},"Compare with GraphQL"),(0,r.kt)("p",null,"GraphQL is a specification, and there are no restrictions about how to  implement it, they are not comparable."),(0,r.kt)("p",null,"However, if only discuss using of RDBMS to implement GraphQL, they are not comparable. The comparison is as follows"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null},"Object Fetcher"),(0,r.kt)("th",{parentName:"tr",align:null},"GraphQL"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Utilize short-lived caches in the query life cycle to prevent repeated data loading"),(0,r.kt)("td",{parentName:"tr",align:null},"Supported"),(0,r.kt)("td",{parentName:"tr",align:null},"Supported")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Solve ",(0,r.kt)("inlineCode",{parentName:"td"},"N + 1")," problem with batch loading"),(0,r.kt)("td",{parentName:"tr",align:null},"Supported"),(0,r.kt)("td",{parentName:"tr",align:null},"Supported")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Parallel execution of different batch loading tasks"),(0,r.kt)("td",{parentName:"tr",align:null},"Not supported"),(0,r.kt)("td",{parentName:"tr",align:null},"Supported")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Add a configuration or parameter to association to filter the associated objects"),(0,r.kt)("td",{parentName:"tr",align:null},"Supported"),(0,r.kt)("td",{parentName:"tr",align:null},"Supported")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Recursively query self-associated properties"),(0,r.kt)("td",{parentName:"tr",align:null},"Supported"),(0,r.kt)("td",{parentName:"tr",align:null},"Not supported")))),(0,r.kt)("p",null,"They have different design purposes, different emphases, and different usage scenarios."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Object fetcher: All data fetching within a query are executed based on the same database connection. Even if the current database transaction has not been committed, the latest data can still be fetched based on the current database connection.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"GraphQL: Only fetch the submitted data, but can use multiple different database connections, so that different batch loading task can be executed concurrently."))),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"In fact, aside from the object fetcher discussed in this article, jimmer-sql has great support for GraphQL as well. In order to accelerate the development efficiency of Spring GraphQL, special API is provided. Please see ",(0,r.kt)("a",{parentName:"p",href:"../spring-graphql"},"Support for Spring GraphQL")," to learn more.")))}k.isMDXComponent=!0},58793:function(e,t,n){t.Z=n.p+"assets/images/shape-877c9a8df8953a5c8b7e0af6f45b8bea.png"}}]);