"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[2340],{3905:function(e,n,t){t.d(n,{Zo:function(){return m},kt:function(){return b}});var a=t(67294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,o=e.originalType,s=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),c=p(t),b=l,d=c["".concat(s,".").concat(b)]||c[b]||u[b]||o;return t?a.createElement(d,i(i({ref:n},m),{},{components:t})):a.createElement(d,i({ref:n},m))}));function b(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var o=t.length,i=new Array(o);i[0]=c;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r.mdxType="string"==typeof e?e:l,i[1]=r;for(var p=2;p<o;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},85162:function(e,n,t){t.d(n,{Z:function(){return i}});var a=t(67294),l=t(34334),o="tabItem_Ymn6";function i(e){var n=e.children,t=e.hidden,i=e.className;return a.createElement("div",{role:"tabpanel",className:(0,l.Z)(o,i),hidden:t},n)}},65488:function(e,n,t){t.d(n,{Z:function(){return b}});var a=t(83117),l=t(67294),o=t(34334),i=t(72389),r=t(67392),s=t(7094),p=t(12466),m="tabList__CuJ",u="tabItem_LNqP";function c(e){var n,t,i=e.lazy,c=e.block,b=e.defaultValue,d=e.values,k=e.groupId,h=e.className,g=l.Children.map(e.children,(function(e){if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),f=null!=d?d:g.map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes}})),N=(0,r.l)(f,(function(e,n){return e.value===n.value}));if(N.length>0)throw new Error('Docusaurus error: Duplicate values "'+N.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var y=null===b?b:null!=(n=null!=b?b:null==(t=g.find((function(e){return e.props.default})))?void 0:t.props.value)?n:g[0].props.value;if(null!==y&&!f.some((function(e){return e.value===y})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+y+'" but none of its children has the corresponding value. Available values are: '+f.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var _=(0,s.U)(),j=_.tabGroupChoices,v=_.setTabGroupChoices,T=(0,l.useState)(y),I=T[0],w=T[1],x=[],O=(0,p.o5)().blockElementScrollPositionUntilNextRender;if(null!=k){var E=j[k];null!=E&&E!==I&&f.some((function(e){return e.value===E}))&&w(E)}var q=function(e){var n=e.currentTarget,t=x.indexOf(n),a=f[t].value;a!==I&&(O(n),w(a),null!=k&&v(k,String(a)))},C=function(e){var n,t=null;switch(e.key){case"ArrowRight":var a,l=x.indexOf(e.currentTarget)+1;t=null!=(a=x[l])?a:x[0];break;case"ArrowLeft":var o,i=x.indexOf(e.currentTarget)-1;t=null!=(o=x[i])?o:x[x.length-1]}null==(n=t)||n.focus()};return l.createElement("div",{className:(0,o.Z)("tabs-container",m)},l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":c},h)},f.map((function(e){var n=e.value,t=e.label,i=e.attributes;return l.createElement("li",(0,a.Z)({role:"tab",tabIndex:I===n?0:-1,"aria-selected":I===n,key:n,ref:function(e){return x.push(e)},onKeyDown:C,onFocus:q,onClick:q},i,{className:(0,o.Z)("tabs__item",u,null==i?void 0:i.className,{"tabs__item--active":I===n})}),null!=t?t:n)}))),i?(0,l.cloneElement)(g.filter((function(e){return e.props.value===I}))[0],{className:"margin-top--md"}):l.createElement("div",{className:"margin-top--md"},g.map((function(e,n){return(0,l.cloneElement)(e,{key:n,hidden:e.props.value!==I})}))))}function b(e){var n=(0,i.Z)();return l.createElement(c,(0,a.Z)({key:String(n)},e))}},87673:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return m},default:function(){return k},frontMatter:function(){return p},metadata:function(){return u},toc:function(){return b}});var a=t(83117),l=t(80102),o=(t(67294),t(3905)),i=t(65488),r=t(85162),s=["components"],p={sidebar_position:5,title:"Table joins"},m=void 0,u={unversionedId:"jimmer-sql/basic/table-join",id:"jimmer-sql/basic/table-join",title:"Table joins",description:"Jimmer's table joins are designed for very complex queries, it have the following features:",source:"@site/docs/jimmer-sql/basic/table-join.mdx",sourceDirName:"jimmer-sql/basic",slug:"/jimmer-sql/basic/table-join",permalink:"/jimmer/docs/jimmer-sql/basic/table-join",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer/tree/main/doc/docs/jimmer-sql/basic/table-join.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Table joins"},sidebar:"tutorialSidebar",previous:{title:"Table and TableEx",permalink:"/jimmer/docs/jimmer-sql/basic/table-and-table-ex"},next:{title:"Expression",permalink:"/jimmer/docs/jimmer-sql/basic/expression"}},c={},b=[{value:"Dynamic join",id:"dynamic-join",level:2},{value:"Example",id:"example",level:3},{value:"Conflict merge rules",id:"conflict-merge-rules",level:3},{value:"Phantom join",id:"phantom-join",level:2},{value:"Half join",id:"half-join",level:2},{value:"Inverse join",id:"inverse-join",level:2}],d={toc:b};function k(e){var n=e.components,t=(0,l.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Jimmer's table joins are designed for very complex queries, it have the following features:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Without explicitly creating table joins, the natural fluent property reference path represents complex multi-table joins, such as:"),(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},'where(table.books.authors.company.city.name eq "ChengDu")'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Table joins that are never used are automatically ignored and do not appear in the final SQL.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"For joined associated object, if only its id property is accessed, jimmer will further ignore more unnecessary join.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Conflicting table joins in different paths will be automatically merged."))),(0,o.kt)("p",null,"This article will introduce the table joins, it contains four parts"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Dynamic join"),(0,o.kt)("li",{parentName:"ul"},"Phantom join"),(0,o.kt)("li",{parentName:"ul"},"Half join"),(0,o.kt)("li",{parentName:"ul"},"Inverse join")),(0,o.kt)("h2",{id:"dynamic-join"},"Dynamic join"),(0,o.kt)("h3",{id:"example"},"Example"),(0,o.kt)("p",null,"Let's look at an example of a dynamic join."),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"@Repository\npublic class BookRepository {\n\n    private final JSqlClient sqlClient;\n\n    public BookRepository(JSqlClient sqlClient) {\n        this.sqlClient = sqlClient;\n    }\n\n    public List<Book> findBooks(\n        @Nullable String name,\n        @Nullable String storeName,\n        @Nullable String storeWebsite\n    ) {\n        BookTable book = BookTable.$;\n        \n        return sqlClient\n            .createQuery(book)\n            .whereIf(\n                name != null,\n                () -> book.name().eq(name)\n            )\n            .whereIf(\n                storeName != null,\n                () -> book\n                    // highlight-next-line\n                    .store() // \u03b1\n                    .name()\n                    .eq(storeName)\n            )\n            .whereIf(\n                storeWebsite != null,\n                () -> book\n                    // highlight-next-line\n                    .store() // \u03b2\n                    .website()\n                    .eq(storeWebsite)\n            )\n            .select(book)\n            .execute();\n    }\n}\n"))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Repository\nclass BookRepository(\n    private val sqlClient: KSqlClient\n) {\n    fun findBooks(\n        name: String?,\n        storeName: String?,\n        storeWebsite: String?\n    ): List<Book> =\n        sqlClient\n            .createQuery(Book::class) {\n                name?.let {\n                    where(table.name eq it)\n                }\n                storeName?.let {\n                    where(\n                        table\n                            // highlight-next-line\n                            .store // \u03b1\n                            .name eq it\n                    )\n                }\n                storeName?.let {\n                    where(\n                        table\n                            // highlight-next-line\n                            .store // \u03b2\n                            .website eq it\n                    )\n                }\n                select(table)\n            }\n            .execute()\n}\n")))),(0,o.kt)("p",null,"This is a typical dynamic query, and all three query parameters are allowed to be null."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"name")," is specified, but ",(0,o.kt)("inlineCode",{parentName:"p"},"storeName")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"storeWebsite")," are still null."),(0,o.kt)("p",{parentName:"li"},"  At this time, the code at ",(0,o.kt)("inlineCode",{parentName:"p"},"\u03b1")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"\u03b2")," will not be executed, and the resulting SQL will not contain any joins."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE, \n    tb_1_.STORE_ID \nfrom BOOK as tb_1_ \n    where tb_1_.NAME = ?\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"storeName")," are specified, but ",(0,o.kt)("inlineCode",{parentName:"p"},"storeWebsite")," is still null."),(0,o.kt)("p",{parentName:"li"},"  At this time, the table join at ",(0,o.kt)("inlineCode",{parentName:"p"},"\u03b1")," takes effect but the code at ",(0,o.kt)("inlineCode",{parentName:"p"},"\u03b2")," will not be executed, and the final generated SQL is as follows."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE, \n    tb_1_.STORE_ID \nfrom BOOK as tb_1_ \n/* highlight-start */\ninner join BOOK_STORE as tb_2_ \n    on tb_1_.STORE_ID = tb_2_.ID\n/* highlight-end */ \nwhere \n    tb_1_.NAME = ? \nand \n    tb_2_.NAME = ?\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"storeWebsite")," are specified, but ",(0,o.kt)("inlineCode",{parentName:"p"},"storeName")," is still null."),(0,o.kt)("p",{parentName:"li"},"  At this time, the table join at ",(0,o.kt)("inlineCode",{parentName:"p"},"\u03b2")," takes effect but the code at ",(0,o.kt)("inlineCode",{parentName:"p"},"\u03b1")," will not be executed, and the final generated SQL is as follows."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE, \n    tb_1_.STORE_ID \nfrom BOOK as tb_1_ \n/* highlight-start */\ninner join BOOK_STORE as tb_2_ \n    on tb_1_.STORE_ID = tb_2_.ID \n/* highlight-end */\nwhere \n    tb_1_.NAME = ? \nand \n    tb_2_.WEBSITE = ?\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Specify all parameters, ",(0,o.kt)("inlineCode",{parentName:"p"},"name"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"storeName")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"storeWebsite")," are non-null."),(0,o.kt)("p",{parentName:"li"},"  At this time, the table joins at ",(0,o.kt)("inlineCode",{parentName:"p"},"\u03b1")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"\u03b2")," take effect, this situation is called a join conflict."),(0,o.kt)("p",{parentName:"li"},"  This conflict does not cause any problems, because in the final SQL, the conflicting table joins will be merged into one instead of join multiple times."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE, \n    tb_1_.STORE_ID \nfrom BOOK as tb_1_ \n    /* highlight-start */\n    inner join BOOK_STORE as tb_2_ on \n        tb_1_.STORE_ID = tb_2_.ID \n    /* highlight-end */\nwhere \n    tb_1_.NAME = ? \nand \n    tb_2_.NAME = ? \nand \n    tb_2_.WEBSITE = ?\n")))),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"summary"),(0,o.kt)("ol",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"There is no need to use local variables to remember join objects like other ORMs, temporary join objects can be created and used anywhere in SQL.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"More importantly, there is no need to consider whether there is some conflict between these join objects, conflicting join objects will be automatically merged."))),(0,o.kt)("p",{parentName:"admonition"},"This feature makes jimmer-sql extremely suitable for implementing complex dynamic queries. It is also one of the motivations for the creation of the jimmer-sql project.")),(0,o.kt)("p",null,"Also, if a table join is created but not used, the table join will be ignored and will not be generated in the final SQL."),(0,o.kt)("h3",{id:"conflict-merge-rules"},"Conflict merge rules"),(0,o.kt)("p",null,"The above example is very simple, the table join in has only one layer. In fact, it is possible to create deeper join objects"),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    store // Assuming that the type of `store` is \n          // BookStoreTableEx, so collection join is allowed\n        // highlight-next-line\n        .books().authors() // multi-level join\n        .firstName()\n        .eq("X")\n);\n'))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    table // Assuming that the type of `table` is \n          // TableEx<BookStore>, so collection join is allowed\n        // highlight-next-line\n        .books.authors // multi-level join\n        .firstName eq "X"\n)\n')))),(0,o.kt)("p",null,"Or"),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    author // Assuming that the type of `author` is \n           // BookStoreTableEx, and collection join is allowed\n        // highlight-next-line\n        .books().store() // multi-level join\n        .name()\n        .eq("X")\n);\n'))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    table // Assuming that the type of `table` is \n          // BookStoreTableEx, and collection join is allowed\n        // highlight-next-line\n        .books.store // multi-level join\n        .name eq "X"\n)\n')))),(0,o.kt)("p",null,"It can be seen that the join object is actually a path of arbitrary length, which can also be called a join path. The join path contains from 1 to infinity of join nodes."),(0,o.kt)("p",null,"In order to make the description more general, let's look at three relatively long join paths ",(0,o.kt)("em",{parentName:"p"},"(there is no such long table join path in an actual project, just to illustrate)"),"."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"a -> b -> c -> d -> e -> f -> g"),(0,o.kt)("li",{parentName:"ol"},"a -> b -> c -> h -> i -> j"),(0,o.kt)("li",{parentName:"ol"},"a -> x -> y -> z -> a-> b -> c -> d")),(0,o.kt)("p",null,"In order to eliminate conflicts, jimmer-sql will merge the nodes in these paths into a tree"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"-+-a\n |\n +----+-b\n |    |\n |    \\----+-c \n |         |\n |         +----+-d\n |         |    |\n |         |    \\----+-e\n |         |         |\n |         |         \\----+-f\n |         |              |\n |         |              \\------g\n |         |\n |         \\----+-h\n |              |\n |              \\----+-i\n |                   |\n |                   \\------j\n |\n \\----+-x\n      |\n      \\----+-y\n           |\n           \\----+-z\n                |\n                \\----+-a\n                     |\n                     \\----+-b\n                          |\n                          \\----+-c\n                               |\n                               \\------d\n")),(0,o.kt)("p",null,"jimmer-sql will generate the join clause in the final SQL based on this tree."),(0,o.kt)("p",null,"Another rule that needs to be explained is the join type. The method that creates the join object has a parameter to specify the join type, for example. For example, deveoper can create left join like this:"),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"book.store(JoinType.LEFT);\n"))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"book.`store?`\n")))),(0,o.kt)("p",null,"The join type merging rules are as follows:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"If the join types of the conflicting join nodes are all the same, the join type remain unchanged after the merge."),(0,o.kt)("li",{parentName:"ul"},"Otherwise, the merged join type is inner join.")),(0,o.kt)("h2",{id:"phantom-join"},"Phantom join"),(0,o.kt)("p",null,"Phantom join is a very simple optimization concept, which can be understood by comparing it with ordinary join."),(0,o.kt)("p",null,"Let's first look at an example of a ordinary table join."),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .where(book.store().name().eq("MANNING"))\n    .select(book)\n    .execute();\n'))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.store.name eq "MANNING")\n        select(table)    \n    }\n    .execute()\n')))),(0,o.kt)("p",null,"The generated SQL is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE, \n    tb_1_.STORE_ID \nfrom BOOK as tb_1_ \n    /* highlight-start */\n    inner join BOOK_STORE as tb_2_ \n        on tb_1_.STORE_ID = tb_2_.ID\n    /* highlight-end */     \nwhere \n    tb_2_.NAME = ?\n")),(0,o.kt)("p",null,"Now, let's look at an example of phantom join"),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .where(\n        book\n        .store()\n        // highlight-next-line\n        .id() // Only id is accessed\n        .eq(2L)\n    )\n    .select(book)\n    .execute();\n"))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table\n            .store\n            // highlight-next-line\n            .id // Only access id \n            eq 2L\n        )\n        select(table)\n    }\n    .execute()\n")))),(0,o.kt)("p",null,"At this time, the generated SQL is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE, \n    tb_1_.STORE_ID \nfrom BOOK as tb_1_ \n    where tb_1_.STORE_ID = ?\n")),(0,o.kt)("p",null,"We don't see any table joins in the SQL, we only see the condition ",(0,o.kt)("inlineCode",{parentName:"p"},"tb_1_.STORE_ID = ?")," based on a foreign key."),(0,o.kt)("p",null,"Reason: For many-to-one associations based on foreign key, the id of the parent table is actually the foreign key of the child table."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"If join object based on foreign key is created but no properties of the associated object other than id is accessed, the join object will be treated as a phantom join. "),(0,o.kt)("p",{parentName:"admonition"},"Phantom join will not generate join clause in SQL.")),(0,o.kt)("h2",{id:"half-join"},"Half join"),(0,o.kt)("p",null,"Half join is a similar concept to a phantom join, but for associations based on middle table."),(0,o.kt)("p",null,"Let's first look at a normal join based on middle table"),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = BookTable.$;\n\nList<Long> bookIds = sqlClient\n    .createQuery(book)\n    .where(\n        book\n            .asTableEx()\n            .authors()\n            .firstName()\n            .eq("Alex")\n    )\n    .select(book.id())\n    .distinct()\n    .execute();\n'))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val bookIds = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table\n                .asTableEx()\n                .authors\n                .firstName eq "Alex"\n        )\n        select(table.id)\n    }\n    .distinct()\n    .execute()\n')))),(0,o.kt)("p",null,"The generated SQL is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    distinct tb_1_.ID \nfrom BOOK as tb_1_ \n/* highlight-start */\ninner join BOOK_AUTHOR_MAPPING as tb_2_ \n    on tb_1_.ID = tb_2_.BOOK_ID \ninner join AUTHOR as tb_3_ on \n    tb_2_.AUTHOR_ID = tb_3_.ID\n/* highlight-end */ \nwhere tb_3_.FIRST_NAME = ?\n")),(0,o.kt)("p",null,"We see that the association based on the middle table will generate two SQL join clauses:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Step1: Join to middle table\n",(0,o.kt)("inlineCode",{parentName:"p"},"inner join BOOK_AUTHOR_MAPPING as tb_2_ on tb_1_.ID = tb_2_.BOOK_ID "))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Step2: join to target table\n",(0,o.kt)("inlineCode",{parentName:"p"},"inner join AUTHOR as tb_3_ on tb_2_.AUTHOR_ID = tb_3_.ID")))),(0,o.kt)("p",null,"Next, let's look at half join"),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Long> bookIds = sqlClient\n    .createQuery(book)\n    .where(\n        book\n            .asTableEx()\n            .authors()\n            // highlight-next-line\n            .id() // Only access id\n            .eq(2L)\n    )\n    .select(book.id())\n    .distinct()\n    .execute();\n"))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val bookIds = sqlClient\n    .createQuery(Book::class) {\n        where(\n            (table as KNullableTableEx<Book>)\n                .authors\n                // highlight-next-line\n                .id // Only access id \n                eq 2L\n        )\n        select(table.id)\n    }\n    .distinct()\n    .execute()\n")))),(0,o.kt)("p",null,"At this time, the generated SQL is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    distinct tb_1_.ID \nfrom BOOK as tb_1_ \n/* highlight-start */\ninner join BOOK_AUTHOR_MAPPING as tb_2_ \n    on tb_1_.ID = tb_2_.BOOK_ID \n/* highlight-end */\nwhere tb_2_.AUTHOR_ID = ?\n")),(0,o.kt)("p",null,"At this time, we only see one SQL join clause, not two"),(0,o.kt)("p",null,"Reason: The id of the associated object is actually a foreign key of middle table."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"If join object based on middle table is created but no properties of the associated object other than id is accessed, the join object will be treated as a half join. "),(0,o.kt)("p",{parentName:"admonition"},"Half join will generate only one join clause point to middle table in SQL, not two.")),(0,o.kt)("h2",{id:"inverse-join"},"Inverse join"),(0,o.kt)("p",null,"All table joins we've discussed so far only apply when java property is already defined in the entity interface."),(0,o.kt)("p",null,"If the developer defines a bidirectional association between entity interfaces"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"A <--\x3e B")),(0,o.kt)("p",null,"We can join from either end to the other, either from ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," or from ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"A"),"."),(0,o.kt)("p",null,"However, sometimes developers only define one-way associations in entity interface."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"A --\x3e B"),"\nNow, we can only join from ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," to B, not from ",(0,o.kt)("inlineCode",{parentName:"p"},"B")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"A"),"."),(0,o.kt)("p",null,"Admittedly, subqueries can solve all problems. However, jimmer-sql still allows you to solve this problem with special table joins, which are called inverse joins."),(0,o.kt)("p",null,"To better illustrate the inverse join, let's first look at normal join."),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    table\n        // Normal join\n        // highlight-next-line\n        .authors\n        .firstName eq "Alex"\n)\n')))),(0,o.kt)("p",null,"There are two ways to write the inverse join that is completely equivalent to it"),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"}),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"})),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Weak typing    "),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    book\n        // Reverse `Auhtor.books`,\n        // it\'s actually `Book.authors`\n        // highlight-next-line\n        .inverseJoin(Author.class, "books")\n        .firstName()\n        .eq("Alex")\n);\n'))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    table\n        // Reverse `Auhtor.books`,\n        // it\'s actually `Book.authors`\n        // highlight-next-line\n        .inverseJoin(Author::class, "books")\n        .firstName eq "Alex"\n)\n'))))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Strong typing"),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    book\n        // Reverse `Auhtor.books`,\n        // it\'s actually `Book.authors`\n        // highlight-next-line\n        .inverseJoin(AuthorProps.BOOKS)\n        .firstName()\n        .eq("Alex")\n);\n'))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    table\n        // Reverse `Auhtor.books`,\n        // it\'s actually `Book.authors`\n        // highlight-next-line\n        .inverseJoin(Author::books)\n        .firstName eq "Alex"\n)\n')))))),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Notice"),(0,o.kt)("p",{parentName:"admonition"},"While inverse joins are easy to understand, the code is relatively obscure to read. Because of this, it should not to be abused."),(0,o.kt)("p",{parentName:"admonition"},"It should only be used in some special cases, such as"),(0,o.kt)("ol",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"The definition of the entity interface belongs to the third party, not the code that can be controlled by your team, and the third-party entity only defines a one-way association, no bidrectional association.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"When developing some generic frameworks, it cannot be assumed that users defined bidirectional associations."))),(0,o.kt)("p",{parentName:"admonition"},"However, in business system development, you should defining bidirectional associations in entity interfaces instead of using inverse joins.")))}k.isMDXComponent=!0}}]);