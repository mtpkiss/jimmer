"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[269],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=d(n),h=l,m=u["".concat(s,".").concat(h)]||u[h]||c[h]||r;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function h(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:l,i[1]=o;for(var d=2;d<r;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},85162:function(e,t,n){n.d(t,{Z:function(){return i}});var a=n(67294),l=n(34334),r="tabItem_Ymn6";function i(e){var t=e.children,n=e.hidden,i=e.className;return a.createElement("div",{role:"tabpanel",className:(0,l.Z)(r,i),hidden:n},t)}},65488:function(e,t,n){n.d(t,{Z:function(){return h}});var a=n(83117),l=n(67294),r=n(34334),i=n(72389),o=n(67392),s=n(7094),d=n(12466),p="tabList__CuJ",c="tabItem_LNqP";function u(e){var t,n,i=e.lazy,u=e.block,h=e.defaultValue,m=e.values,k=e.groupId,f=e.className,b=l.Children.map(e.children,(function(e){if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),g=null!=m?m:b.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),N=(0,o.l)(g,(function(e,t){return e.value===t.value}));if(N.length>0)throw new Error('Docusaurus error: Duplicate values "'+N.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var y=null===h?h:null!=(t=null!=h?h:null==(n=b.find((function(e){return e.props.default})))?void 0:n.props.value)?t:b[0].props.value;if(null!==y&&!g.some((function(e){return e.value===y})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+y+'" but none of its children has the corresponding value. Available values are: '+g.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var v=(0,s.U)(),C=v.tabGroupChoices,T=v.setTabGroupChoices,w=(0,l.useState)(y),j=w[0],B=w[1],I=[],A=(0,d.o5)().blockElementScrollPositionUntilNextRender;if(null!=k){var S=C[k];null!=S&&S!==j&&g.some((function(e){return e.value===S}))&&B(S)}var q=function(e){var t=e.currentTarget,n=I.indexOf(t),a=g[n].value;a!==j&&(A(t),B(a),null!=k&&T(k,String(a)))},x=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a,l=I.indexOf(e.currentTarget)+1;n=null!=(a=I[l])?a:I[0];break;case"ArrowLeft":var r,i=I.indexOf(e.currentTarget)-1;n=null!=(r=I[i])?r:I[I.length-1]}null==(t=n)||t.focus()};return l.createElement("div",{className:(0,r.Z)("tabs-container",p)},l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":u},f)},g.map((function(e){var t=e.value,n=e.label,i=e.attributes;return l.createElement("li",(0,a.Z)({role:"tab",tabIndex:j===t?0:-1,"aria-selected":j===t,key:t,ref:function(e){return I.push(e)},onKeyDown:x,onFocus:q,onClick:q},i,{className:(0,r.Z)("tabs__item",c,null==i?void 0:i.className,{"tabs__item--active":j===t})}),null!=n?n:t)}))),i?(0,l.cloneElement)(b.filter((function(e){return e.props.value===j}))[0],{className:"margin-top--md"}):l.createElement("div",{className:"margin-top--md"},b.map((function(e,t){return(0,l.cloneElement)(e,{key:t,hidden:e.props.value!==j})}))))}function h(e){var t=(0,i.Z)();return l.createElement(u,(0,a.Z)({key:String(t)},e))}},63825:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return p},default:function(){return k},frontMatter:function(){return d},metadata:function(){return c},toc:function(){return h}});var a=n(83117),l=n(80102),r=(n(67294),n(3905)),i=n(65488),o=n(85162),s=["components"],d={sidebar_position:4,title:"Gobal Filter"},p=void 0,c={unversionedId:"jimmer-sql/advanced/filter",id:"jimmer-sql/advanced/filter",title:"Gobal Filter",description:"In actual projects, there is a type of requirement that is very common, such as",source:"@site/docs/jimmer-sql/advanced/filter.mdx",sourceDirName:"jimmer-sql/advanced",slug:"/jimmer-sql/advanced/filter",permalink:"/jimmer/docs/jimmer-sql/advanced/filter",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer/tree/main/doc/docs/jimmer-sql/advanced/filter.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Gobal Filter"},sidebar:"tutorialSidebar",previous:{title:"Calculated property and its cache",permalink:"/jimmer/docs/jimmer-sql/advanced/calculated-prop"},next:{title:"Use spring boot starter",permalink:"/jimmer/docs/jimmer-sql/spring-boot"}},u={},h=[{value:"Provide filter",id:"provide-filter",level:2},{value:"Provides an abstract entity base class",id:"provides-an-abstract-entity-base-class",level:3},{value:"Define filter",id:"define-filter",level:3},{value:"Configure filter",id:"configure-filter",level:3},{value:"Filter aggregate root objects",id:"filter-aggregate-root-objects",level:2},{value:"filter associated objects",id:"filter-associated-objects",level:2},{value:"Enable/disable filter",id:"enabledisable-filter",level:2},{value:"Sharding Filter",id:"sharding-filter",level:2},{value:"Filters and Caching",id:"filters-and-caching",level:2},{value:"Make the filter support cache",id:"make-the-filter-support-cache",level:3},{value:"Make the cache support parameterized",id:"make-the-cache-support-parameterized",level:3},{value:"Consistency for Parameterized Caches",id:"consistency-for-parameterized-caches",level:2},{value:"Filters and calculated  properties",id:"filters-and-calculated--properties",level:2}],m={toc:h};function k(e){var t=e.components,n=(0,l.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In actual projects, there is a type of requirement that is very common, such as"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Soft delete"),(0,r.kt)("p",{parentName:"li"},'The delete operation at the business level does not correspond to the delete operation of the database, but sets a "deleted" state for the data. Most of the query operations do not query the data with the "deleted" state. In this way, data marked as "deleted" will be hiden until the "deleted" state is revoked.')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Multi-tenancy"),(0,r.kt)("p",{parentName:"li"},'The data has a "tenant" field. If the login information of the system can also be parsed into "current tenant", the "current tenant" is used to filter the query data, so that visitors of different tenants can see different data after logging in.')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Data authorization"),(0,r.kt)("p",{parentName:"li"},"The data may be indirectly related to the user through certain authorization-related associations. Using the login identity, each user can only query the data he is authorized to access."))),(0,r.kt)("p",null,"The above requirements are essentially the same. This is a requirement to implicitly implant where conditions for queries. Jimmer provides global filters to solve this problem."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"If the reader is familiar with the Oracle database, you can use ",(0,r.kt)("a",{parentName:"p",href:"https://docs.oracle.com/database/121/DBSEG/vpd.htm"},"VPD")," to understand by analogy. Jimmer global filters introduce Oracle VPD-like capabilities for all databases.")),(0,r.kt)("p",null,"Among the above requirements, the complexity of multi-tenancy is relatively moderate. This article uses multi-tenancy as an example to explain global filters."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"In some multi-tenant systems, data of different tenants needs to be stored in separate tables or even separate databases."),(0,r.kt)("p",{parentName:"admonition"},"If there is a request in this regard, please use it in conjunction with ",(0,r.kt)("a",{parentName:"p",href:"https://shardingsphere.apache.org/document/4.1.1/en/manual/sharding-jdbc/"},"sharding-jdbc"),". Solve the problem of database sharding and table sharding at the JDBC level instead of the ORM level.")),(0,r.kt)("h2",{id:"provide-filter"},"Provide filter"),(0,r.kt)("h3",{id:"provides-an-abstract-entity-base-class"},"Provides an abstract entity base class"),(0,r.kt)("p",null,"First, provide a ",(0,r.kt)("inlineCode",{parentName:"p"},"MappedSuperclass")," superclass, all entity classes that need multi-tenant management can inherit it"),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"@MappedSuperclass\npublic interface TenantAware {\n\n    String tenant();\n}\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"@MappedSuperclass\ninterface TenantAware {\n\n    val tenant: String\n}\n")))),(0,r.kt)("h3",{id:"define-filter"},"Define filter"),(0,r.kt)("p",null,"In the following example, the Java method ",(0,r.kt)("inlineCode",{parentName:"p"},"get()")," or the kotlin property ",(0,r.kt)("inlineCode",{parentName:"p"},"tenant")," of the ",(0,r.kt)("inlineCode",{parentName:"p"},"TenantProvider")," class is used to return the tenant to which the current user belongs."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Under Java, the interceptor needs to implement the ",(0,r.kt)("inlineCode",{parentName:"li"},"org.babyfish.jimmer.sql.filter.Filter")," interface,"),(0,r.kt)("li",{parentName:"ul"},"Under Kotlin, the interceptor needs to implement the ",(0,r.kt)("inlineCode",{parentName:"li"},"org.babyfish.jimmer.sql.kt.filter.KFilter")," interface.")),(0,r.kt)("p",null,"If using Spring hosting, the code is as follows:"),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"@Component\npublic class TenantFilter implements Filter<TenantAwareProps> {\n\n    protected final TenantProvider tenantProvider;\n\n    public TenantFilter(TenantProvider tenantProvider) {\n        this.tenantProvider = tenantProvider;\n    }\n\n    @Override\n    public void filter(FilterArgs<TenantAwareProps> args) {\n        String tenant = tenantProvider.get();\n        if (tenant != null) {\n            args.where(args.getTable().tenant().eq(tenant));\n        }\n    }\n}\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Component\nclass TenantFilter(\n    protected val tenantProvider: TenantProvider\n) : KFilter<TenantAware> {\n\n    override fun filter(args: KFilterArgs<TenantAware>) {\n        tenantProvider.tenant?.let {\n            args.apply {\n                where(table.tenant.eq(it))\n            }\n        }\n    }\n}\n")))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"TenantFilter")," first extracts the tenant of the current user. If the tenant is not null, use it to filter the data, and only query the data that matches the specified tenant."),(0,r.kt)("h3",{id:"configure-filter"},"Configure filter"),(0,r.kt)("p",null,"Hook the filter to the SqlClient object to take effect"),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"@Bean\npublic JSqlClient sqlClient(\n    List<Filter<?>> filters,\n    ...Omit other parameters...\n) {\n    return JSqlBuilder\n        .newBuilder()\n        // highlight-next-line\n        .addFilters(filters)\n        ...Omit other configuration...\n        .build();\n}\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Bean\nfun sqlClient(\n    filters: List<KFilter<?>>,\n    ...Omit other parameters...\n): KSqlClient =\n    newKSqlClient {\n        // highlight-next-line\n        addFilters(filters)\n        ...Omit other configuration...\n    }\n")))),(0,r.kt)("p",null,"Although only one ",(0,r.kt)("inlineCode",{parentName:"p"},"Filter"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"KFilter")," is demonstrated here, there may be many filters in the actual project."),(0,r.kt)("p",null,"So, use a collection here and let Spring inject all ",(0,r.kt)("inlineCode",{parentName:"p"},"Filter"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"KFilter")," objects."),(0,r.kt)("h2",{id:"filter-aggregate-root-objects"},"Filter aggregate root objects"),(0,r.kt)("p",null,"Filtering aggregate root objects is the simplest use of global filters."),(0,r.kt)("p",null,"Assuming that the ",(0,r.kt)("inlineCode",{parentName:"p"},"Book")," entity inherits ",(0,r.kt)("inlineCode",{parentName:"p"},"TenantAware"),", the usage is as follows"),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"List<Book> books = sqlClient.getEntities.findAll(Book.class);\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient.entities.findAll(Book::class);\n")))),"Or",(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(book)\n    .execute();\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = SqlClient\n    .createQuery(Book::class) {\n        select(table)\n    }\n    .execute()\n")))),(0,r.kt)("p",null,"The generated SQL is as follows"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.TENANT, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE, \n    tb_1_.STORE_ID \nfrom BOOK as tb_1_\n/* highlight-next-line */ \nwhere tb_1_.TENANT = ?\n")),(0,r.kt)("p",null,"It is not difficult to find that the simplest query is used here, without any sql conditional. Howvery, the final generated SQL still filters ",(0,r.kt)("inlineCode",{parentName:"p"},"tb_1_.TENANT")),(0,r.kt)("h2",{id:"filter-associated-objects"},"filter associated objects"),(0,r.kt)("p",null,"Not only aggregate root objects can be filtered, but also associated objects can be filtered."),(0,r.kt)("p",null,"Assuming that the ",(0,r.kt)("inlineCode",{parentName:"p"},"Book")," entity inherits ",(0,r.kt)("inlineCode",{parentName:"p"},"TenantAware"),", the usage is as follows"),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"List<Author> authors = sqlClient.getEntities.findAll(\n    AuthorFetcher.$\n        .allScalarFields()\n        // highlight-next-line\n        .books(\n            BookFetcher.$\n                .allScalarFields()\n        )\n);\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient.entities.findAll(\n    newFetcher(Author::class).by {\n        allScalarFields()\n        // highlight-next-line\n        books {\n            allScalarFields()\n        }\n    }\n);\n")))),"or",(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"AuthorTable author = AuthorTable.$;\nList<Author> authors = sqlClient\n    .createQuery(author)\n    .select(\n        author.fetch(\n            AuthorFetcher.$\n                .allScalarFields()\n                // highlight-next-line\n                .books(\n                    BookFetcher.$\n                        .allScalarFields()\n                )\n        )\n    )\n    .execute();\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val authors = SqlClient\n    .createQuery(Author::class) {\n        select(\n            table.fetchBy {\n                allScalarFields()\n                // highlight-next-line\n                books {\n                    allScalarFields()\n                }\n            }\n        )\n    }\n    .execute()\n")))),(0,r.kt)("p",null,"This will result in the following two SQL statements being generated"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Query aggregate root objects"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, tb_1_.FIRST_NAME, tb_1_.LAST_NAME, tb_1_.GENDER \nfrom AUTHOR as tb_1_\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Query associated objects"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_2_.AUTHOR_ID, \n    tb_1_.ID, \n    tb_1_.TENANT, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE \nfrom BOOK as tb_1_ \ninner join BOOK_AUTHOR_MAPPING as tb_2_ \n    on tb_1_.ID = tb_2_.BOOK_ID \nwhere \n    tb_2_.AUTHOR_ID in (?, ?, ?, ?, ?) \nand \n    /* highlight-next-line */\n    tb_1_.TENANT = ?\n")))),(0,r.kt)("p",null,"It's not hard to see that an object fetcher is used here. Although the object fetcher does not impose any ","[field-level filters]"," (../query/fetcher#field-filters) on the associated property ",(0,r.kt)("inlineCode",{parentName:"p"},"Author.books"),", the global filters for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Book")," class still take effect. As a result, the final generated SQL still filters tenant field."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The filtering of associated objects is demonstrated here through ",(0,r.kt)("a",{parentName:"p",href:"../query/fetcher"},"object fetcher"),". In fact, the ",(0,r.kt)("a",{parentName:"p",href:"../spring-graphql"},"GraphQL")," function provided by Jimmer can also use global filters to filter associated objects.")),(0,r.kt)("h2",{id:"enabledisable-filter"},"Enable/disable filter"),(0,r.kt)("p",null,"In this section, we take soft delete as an example, assuming there are two filter classes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'UndeletedFilter: query data whose with "deleted" state'),(0,r.kt)("li",{parentName:"ul"},'DeletedFilter: query data whose without "deleted" state')),(0,r.kt)("p",null,"Soft-deleting is very simple, and there is no need to show the code for both filters."),(0,r.kt)("p",null,"Now, we hook these two filters to SqlClient"),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"@Bean\npublic JSqlClient sqlClient(\n    List<Filter<?>> filters,\n    ...Omit other parameters...\n) {\n    return JSqlBuilder\n        .newBuilder()\n        .addFilters(new UndeletedFilter())\n        // highlight-next-line\n        .addDisabledFilters(new DeletedFilter())\n        ...Omit other configuration...\n        .build();\n}\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Bean\nfun sqlClient(\n    filters: List<KFilter<?>>,\n    ...Omit other parameters...\n): KSqlClient =\n    newKSqlClient {\n        .addFilters(UndeletedFilter())\n        // highlight-next-line\n        .addDisabledFilters(DeletedFilter())\n        ...Omit other configuration...\n    }\n")))),(0,r.kt)("p",null,"Obviously, if both filters are used at the same time, no data will be queried."),(0,r.kt)("p",null,"So, ",(0,r.kt)("inlineCode",{parentName:"p"},"DeletedFilter")," is added, but not enabled. And ",(0,r.kt)("inlineCode",{parentName:"p"},"UndeletedFilter")," is enabled, by default, all businesses care about undeleted data."),(0,r.kt)("p",null,"If there is a small amount of business out of the ordinary, do not view the data that has not been deleted, but specifically view the data that has already been deleted"),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"JSqlClient tmpSqlClient =\n    sqlClient.filters(it -> {\n        it\n            // highlight-next-line\n            .disableByTypes(UndeletedFilter.class);\n            // highlight-next-line\n            .enableByTypes(DeletedFilter.class);\n    });\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val tmpSqlClient = \n    sqlClient.filters {\n        // highlight-next-line\n        disableByTypes(UndeletedFilter::class)\n        // highlight-next-line\n        enableByTypes(DeletedFilter::class)\n    }\n")))),(0,r.kt)("p",null,"Here, we disable the originally enabled ",(0,r.kt)("inlineCode",{parentName:"p"},"UndeletedFilter"),", and enable the originally disabled ",(0,r.kt)("inlineCode",{parentName:"p"},"DeletedFilter"),", creating a new ",(0,r.kt)("inlineCode",{parentName:"p"},"tmpSqlClient"),"."),(0,r.kt)("p",null,"The behavior of ",(0,r.kt)("inlineCode",{parentName:"p"},"tmpSqlClient")," is just the opposite of the default ",(0,r.kt)("inlineCode",{parentName:"p"},"sqlClient"),". It does not query data that has not been deleted, but specifically queries data that has been deleted."),(0,r.kt)("h2",{id:"sharding-filter"},"Sharding Filter"),(0,r.kt)("p",null,"By default, querying objects by id using the Simple Query API will not apply filters, including both the user's ",(0,r.kt)("inlineCode",{parentName:"p"},"sqlClient.entities.findById(s)")," behavior and jimmer's internal behavior about use the object cache to convert ids to objects."),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"Notice: "),(0,r.kt)("p",{parentName:"admonition"},"This refers to querying objects directly by id, rather than resvoling many-to-one associations based on foreign keys in object fetcher."),(0,r.kt)("p",{parentName:"admonition"},"Even if the foreign key data is not null, if the parent object does not meet its filter conditions, the object fetcher will consider the parent object to be null."),(0,r.kt)("p",{parentName:"admonition"},"At this point, if the many-to-one associated property is not nullable, it will cause an exception."),(0,r.kt)("p",{parentName:"admonition"},"There are two ways to fetch many-to-one associations based on foreign keys:"),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Using an object fetcher, explicitly fetch a foreign key based many-to-one association, or implicitly use the object fetchers ",(0,r.kt)("inlineCode",{parentName:"p"},"allTableFields()")," method")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Instead of using the object fetcher, query the table object directly. In this case all foreign keys will be set to the id-only parent object or null"))),(0,r.kt)("p",{parentName:"admonition"},"Among them, the filter will be applied in the first case, and will not be appiled in the second case.")),(0,r.kt)("p",null,"In most cases, query object(s) by is(s) ignores the filter, because the id uniquely identifies the unique object."),(0,r.kt)("p",null,"However, if the ",(0,r.kt)("a",{parentName:"p",href:"https://shardingsphere.apache.org/document/4.1.1/en/manual/sharding-jdbc/"},"sharding-jdbc")," technology is used at the JDBC level, and the field to which the filter applies is the sharding field of sharding-jdbc, at this time, querying by only id is a disaster for sharding-jdbc."),(0,r.kt)("p",null,"In order to solve this problem, let the filter implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"ShardingFilter")," interface",(0,r.kt)("em",{parentName:"p"},"(Java)")," or the ",(0,r.kt)("inlineCode",{parentName:"p"},"KShardingFilter")," interface",(0,r.kt)("em",{parentName:"p"},"(Kotlin)"),", which has no methods, just type marking."),(0,r.kt)("p",null,"Once the filter is ",(0,r.kt)("inlineCode",{parentName:"p"},"ShardingFilter")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"KShardingFilter"),", the id-based simple query corresponding to the simple query API, whether it is the user's ",(0,r.kt)("inlineCode",{parentName:"p"},"sqlClient.entities.findById(s)")," behavior or Jimmer internal behavior, will no longer ignore filtering this filter, persist to apply the filter condition."),(0,r.kt)("p",null,"This ensures that the final SQL must contain the condition of sharding fields required by sharding-jdbc, so that only a single sharding database is queried instead of all sharding databases being queried once."),(0,r.kt)("h2",{id:"filters-and-caching"},"Filters and Caching"),(0,r.kt)("p",null,"As mentioned earlier, global filters can be used in conjunction with ",(0,r.kt)("a",{parentName:"p",href:"../query/fetcher"},"object fetcher")," or GraphQL to filter associated objects."),(0,r.kt)("p",null,"This means that different operators can see different object associations."),(0,r.kt)("p",null,"However, in the ",(0,r.kt)("a",{parentName:"p",href:"./cache"},"External Cache")," article, we mention that Jimmer supports associative caching that looks like this"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"key"),(0,r.kt)("th",{parentName:"tr",align:null},"value"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Author.boooks-1"),(0,r.kt)("td",{parentName:"tr",align:null},"[1, 2, 3]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Author.boooks-2"),(0,r.kt)("td",{parentName:"tr",align:null},"[4, 5, 6]")))),(0,r.kt)("p",null,"This means that the books associated with the author whose ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," are ",(0,r.kt)("inlineCode",{parentName:"p"},"1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"2"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"3"),", while the books associated with the author whose ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"2")," are ",(0,r.kt)("inlineCode",{parentName:"p"},"4"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"5")," ",(0,r.kt)("inlineCode",{parentName:"p"},"and"),"6`."),(0,r.kt)("p",null,"In this example, the many-to-many association of ",(0,r.kt)("inlineCode",{parentName:"p"},"Author.books")," is described by the cache, however, all users see the same cached data, However, the global filter that allows different users to see different object associations."),(0,r.kt)("p",null,"Let Jimmer supports more advanced cache functions, and cooperates with global filters, so that different users can see different cache-data. Such a cache structure should be look like "),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"key"),(0,r.kt)("th",null,"hash"),(0,r.kt)("th",null,"value"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",{rowspan:"3"},"Author.boooks-1"),(0,r.kt)("td",null,"{}"),(0,r.kt)("td",null,"[1, 2, 3]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,'{"tenant":"a"}'),(0,r.kt)("td",null,"[1, 3]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,'{"tenant":"b"}'),(0,r.kt)("td",null,"[2]")),(0,r.kt)("tr",null,(0,r.kt)("td",{rowspan:"3"},"Author.boooks-2"),(0,r.kt)("td",null,"{}"),(0,r.kt)("td",null,"[4, 5, 6]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,'{"tenant":"a"}'),(0,r.kt)("td",null,"[4, 6]")),(0,r.kt)("tr",null,(0,r.kt)("td",null,'{"tenant":"b"}'),(0,r.kt)("td",null,"[5]")))),(0,r.kt)("p",null,"Here we see cache entry inflation, the more cache is consumed if more filter parameters are active."),(0,r.kt)("p",null,"Therefore, this capability should only be used for important associations, and redis clustering is recommended."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Does the filter support cache"),(0,r.kt)("th",{parentName:"tr",align:null},"Does the cache support parameterization"),(0,r.kt)("th",{parentName:"tr",align:null},"Final effect"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"NA"),(0,r.kt)("td",{parentName:"tr",align:null},"Do not use association cache")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"Use association cache, but only cache the results of the parameterless filter")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Use an associative cache, and cache the results of all filters ",(0,r.kt)("em",{parentName:"td"}," (that is, the new cache strucuture discuessed above)"))))),(0,r.kt)("p",null,"From this, if you want to provide caching for all filter parameters, the developer needs to"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Make filters support caching"),(0,r.kt)("li",{parentName:"ul"},"Make the cache support parameterization")),(0,r.kt)("h3",{id:"make-the-filter-support-cache"},"Make the filter support cache"),(0,r.kt)("p",null,"To enable the filter to support cache"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"For Java, the ",(0,r.kt)("inlineCode",{parentName:"li"},"org.babyfish.jimmer.sql.filter.CacheableFilter")," interface needs to be implemented,"),(0,r.kt)("li",{parentName:"ul"},"For Kotlin, the ",(0,r.kt)("inlineCode",{parentName:"li"},"org.babyfish.jimmer.sql.kt.filter.KCacheableFilter")," interface needs to be implemented.")),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@Component\npublic class TenantFilter implements Filter<TenantAwareProps> {\n\n    protected final TenantProvider tenantProvider;\n\n    public TenantFilterForNonCacheMode(TenantProvider tenantProvider) {\n        this.tenantProvider = tenantProvider;\n    }\n\n    @Override\n    public void filter(FilterArgs<TenantAwareProps> args) {\n        String tenant = tenantProvider.get();\n        if (tenant != null) {\n            args.where(args.getTable().tenant().eq(tenant));\n        }\n    }\n\n    // highlight-next-line\n    @Override\n    public SortedMap<String, Object> getParameters() {\n        String tenant = tenantProvider.get();\n        if (tenant == null) {\n            return null;\n        }\n        SortedMap<String, Object> map = new TreeMap<>();\n        map.put("tenant", tenant);\n        return map;\n    }\n\n    ...\u5ffd\u7565\u5176\u4ed6\u65b9\u6cd5...\n}\n'))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'@Component\nclass TenantFilter(\n    protected val tenantProvider: TenantProvider\n) : KFilter<TenantAware> {\n\n    override fun filter(args: KFilterArgs<TenantAware>) {\n        tenantProvider.tenant?.let {\n            args.apply {\n                where(table.tenant.eq(it))\n            }\n        }\n    }\n\n    // highlight-next-line\n    override fun getParameters(): SortedMap<String, Any>? =\n        tenantProvider.tenant?.let {\n            sortedMapOf("tenant" to it)\n        }\n\n    ...\u5ffd\u7565\u5176\u4ed6\u65b9\u6cd5...\n}\n')))),(0,r.kt)("p",null,"Implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"getParameters()")," method for ",(0,r.kt)("inlineCode",{parentName:"p"},"CacheableFilter"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"KCacheableFilter"),", returning a map."),(0,r.kt)("p",null,"In this examples, only one filter is used. If an entity class is filtered by multiple filters, the system will automatically combine the multiple filters into one filter."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Any filter does not support cache, and the final merged filter does not support cache"),(0,r.kt)("li",{parentName:"ul"},"If all filters support cache, the map returned by the ",(0,r.kt)("inlineCode",{parentName:"li"},"getParameters()")," method of the merged filter is the union of all the maps returned by the ",(0,r.kt)("inlineCode",{parentName:"li"},"getParameters()")," method of the original filters")),(0,r.kt)("p",null,"If the association cache supports parameterization, that is, the cache is a nested 2-layer KeyValue structure, then the combined filter returns a map, which can be used as the key of the inner KeyValue structure after being serialized into a string."),(0,r.kt)("h3",{id:"make-the-cache-support-parameterized"},"Make the cache support parameterized"),(0,r.kt)("p",null,"In order for the cache to be a nested two-level KeyValue structure, the cache needs to implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"Cache.Parameterized<K, V>")," interface"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Cache.java"',title:'"Cache.java"'},"// Ordinary cache\npublic interface Cache<K, V> {\n\n    ...Ommit methods...\n\n    // Parameterized cache\n    // highlight-next-line\n    interface Parameterized<K, V> extends Cache<K, V> {\n\n        ...Ommit methods...\n    }\n}\n")),(0,r.kt)("p",null,"The code to create the cache is as follows"),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"Cache<K, V> cache = new ChainCacheBuilder<K, V>()\n    .add(level1Binder)\n    .add(level2Binder)\n    ... \n    .add(levelNBinder)\n    .build()\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"Cache<K, V> cache = ChainCacheBuilder<K, V>()\n    .add(level1Binder)\n    .add(level2Binder)\n    ... \n    .add(levelNBinder)\n    .build()\n")))),(0,r.kt)("p",null,"Even with parameterized caches, you only need to declare variables of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Cache<K, V>"),". The developer only needs to create an object instance of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Cache.Parameterized<K, V>"),"."),(0,r.kt)("p",null,"In order to build a multi-level cache, you need to build ",(0,r.kt)("inlineCode",{parentName:"p"},"Binder")," objects"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the cache can be automatically loaded, such as caffine, guava"),(0,r.kt)("table",{parentName:"li"},(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null},"Ordinary binder"),(0,r.kt)("th",{parentName:"tr",align:null},"Binder for ",(0,r.kt)("strong",{parentName:"th"},"parameterized")," cache"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Interfaces that Java needs to implement"),(0,r.kt)("td",{parentName:"tr",align:null},"LoadingBinder<K, V>"),(0,r.kt)("td",{parentName:"tr",align:null},"LoadingBinder.",(0,r.kt)("strong",{parentName:"td"},"Parameterized"),"<K, V>")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Interfaces that Kotlin needs to implement"),(0,r.kt)("td",{parentName:"tr",align:null},"KLoadingBinder<K, V>"),(0,r.kt)("td",{parentName:"tr",align:null},"KLoadingBinder.",(0,r.kt)("strong",{parentName:"td"},"Parameterized"),"<K, V>"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the cache cannot be loaded automatically, jimmer needs to call its set, such as redis"),(0,r.kt)("table",{parentName:"li"},(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null},"Ordinary binder"),(0,r.kt)("th",{parentName:"tr",align:null},"Binder for ",(0,r.kt)("strong",{parentName:"th"},"parameterized")," cache"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Interfaces that Java needs to implement"),(0,r.kt)("td",{parentName:"tr",align:null},"SimpleBinder<K, V>"),(0,r.kt)("td",{parentName:"tr",align:null},"SimpleBinder.",(0,r.kt)("strong",{parentName:"td"},"Parameterized"),"<K, V>")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Interfaces that Kotlin needs to implement"),(0,r.kt)("td",{parentName:"tr",align:null},"KSimpleBinder<K, V>"),(0,r.kt)("td",{parentName:"tr",align:null},"KSimpleBinder.",(0,r.kt)("strong",{parentName:"td"},"Parameterized"),"<K, V>")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Recommended abstract base class for Java"),(0,r.kt)("td",{parentName:"tr",align:null},"AbstractRemoteValueBinder<K, V>"),(0,r.kt)("td",{parentName:"tr",align:null},"AbstractRemote",(0,r.kt)("strong",{parentName:"td"},"Hash"),"Binder<K, V>")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Recommended abstract base class for Kotlin"),(0,r.kt)("td",{parentName:"tr",align:null},"AbstractKRemoteValueBinder<K, V>"),(0,r.kt)("td",{parentName:"tr",align:null},"AbstractKRemote",(0,r.kt)("strong",{parentName:"td"},"Hash"),"Binder<K, V>")))))),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"When building a multi-level cache"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"If all ",(0,r.kt)("inlineCode",{parentName:"li"},"Binder"),"s are parameterized, the resulting cache is also parameterized"),(0,r.kt)("li",{parentName:"ul"},"If all ",(0,r.kt)("inlineCode",{parentName:"li"},"Binder"),"s are non-parameterized, the resulting cache is also non-parameterized"),(0,r.kt)("li",{parentName:"ul"},"If the two ",(0,r.kt)("inlineCode",{parentName:"li"},"Binder")," are mixed, an error will be reported"))),(0,r.kt)("p",null,"Provide a derived class for ",(0,r.kt)("inlineCode",{parentName:"p"},"AbstractRemoteHashBinder")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"AbstractKRemoteHashBinder"),", which can quickly implement parameterized cache ",(0,r.kt)("inlineCode",{parentName:"p"},"Binder"),", and further implement parameterized cache."),(0,r.kt)("p",null,"I won't go into details here, please refer to the implementation of ",(0,r.kt)("inlineCode",{parentName:"p"},"RedisHashBinder")," in the example attached to the project, please click ","[Java Demonstration Link]","(",(0,r.kt)("a",{parentName:"p",href:"https://github.com/babyfish-ct/jimmer/blob/main/example/java/jimmer-sql"},"https://github.com/babyfish-ct/jimmer/blob/main/example/java/jimmer-sql")," /src/main/java/org/babyfish/jimmer/sql/example/cache/binder/RedisHashBinder.java) or ","[Kotlin demo link]","(",(0,r.kt)("a",{parentName:"p",href:"https://github.com/babyfish-ct/jimmer/blob/main/"},"https://github.com/babyfish-ct/jimmer/blob/main/")," example/kotlin/jimmer-sql-kt/src/main/kotlin/org/babyfish/jimmer/example/kt/sql/cache/binder/RedisHashBinder.kt)"),(0,r.kt)("p",null,"Finally, with the help of ",(0,r.kt)("inlineCode",{parentName:"p"},"RedisHashBinder"),", we can configure association caches and calucation caches as parameterized caches"),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"@Bean\npublic JSqlClient sqlClient(\n    RedisTemplate<stirng, byte[]> redisTemplate,\n    ObjectMapper objectMapper,\n    ...Other parameters...\n) {\n    return JSqlBuilder\n        .newBuilder()\n        // Before setting Cache, EntityManager must be set first\n        .setEntityManager(\n            JimmerModule.ENTITY_MANAGER // Auto generated constant \n        )\n        .setCaches(it -> {\n            it.setCacheFactory(\n                new CacheFactory() {\n\n                    // Object cache, ordinary cache is enough\n                    @Override\n                    public Cache<?, ?> createObjectCache(ImmutableType type) {\n                        return new ChainCacheBuilder<>()\n                                .add(new CaffeineBinder<>(512, Duration.ofSeconds(1)))\n                                .add(\n                                    new RedisValueBinder<>(\n                                        redisTemplate, \n                                        objectMapper, \n                                        type, \n                                        Duration.ofMinutes(10)\n                                    )\n                                )\n                                .build();\n                    }\n\n                    // One-to-one/many-to-one association cache, support parameterization \n                    @Override\n                    public Cache<?, ?> createAssociatedIdCache(ImmutableProp prop) {\n                        return new ChainCacheBuilder<>()\n                                .add(\n                                    // highlight-next-line\n                                    new RedisHashBinder<>(\n                                        redisTemplate, \n                                        objectMapper, \n                                        prop, \n                                        Duration.ofMinutes(5)\n                                    )\n                                )\n                                .build();\n                    }\n\n                    // One-to-many/many-to-many association cache, support parameterization \n                    @Override\n                    public Cache<?, List<?>> createAssociatedIdListCache(ImmutableProp prop) {\n                        return new ChainCacheBuilder<Object, List<?>>()\n                                .add(\n                                    // highlight-next-line\n                                    new RedisHashBinder<>(\n                                        redisTemplate, \n                                        objectMapper, \n                                        prop, \n                                        Duration.ofMinutes(5)\n                                    )\n                                )\n                                .build();\n                    }\n\n                    // Calculated property cache, support parameterization \n                    @Override\n                    public Cache<?, ?> createResolverCache(ImmutableProp prop) {\n                        return new ChainCacheBuilder<Object, List<?>>()\n                                .add(\n                                    // highlight-next-line\n                                    new RedisHashBinder<>(\n                                        redisTemplate, \n                                        objectMapper, \n                                        prop, \n                                        Duration.ofHours(1)\n                                    )\n                                )\n                                .build();\n                    }\n                }\n            )\uff1b\n        })\n        ...Omit other configuration...\n        .build()\n}\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Bean\nfun sqlClient(\n    redisTemplate: RedisTemplate<stirng, ByteArray>,\n    objectMapper: ObjectMapper,\n    ...\u5176\u4ed6\u53c2\u6570...\n): KSqlClient =\n    newKSqlClient {\n        // Before setting Cache, EntityManager must be set first\n        setEntityManager(\n            ENTITY_MANAGER // Auto generated constant\n        )\n        setCacheFactory {\n            setCacheFactory(\n                object : CacheFactory {\n\n                    // Object cache, ordinary cache is enough\n                    override fun createObjectCache(type: ImmutableType): Cache<*, *>? =\n                        ChainCacheBuilder<Any, Any>()\n                            .add(CaffeineBinder(512, Duration.ofSeconds(1)))\n                            .add(\n                                RedisValueBinder(\n                                    redisTemplate, \n                                    objectMapper, \n                                    type, \n                                    Duration.ofMinutes(10)\n                                )\n                            )\n                            .build()\n\n                    // One-to-one/many-to-one association cache, support parameterization \n                    override fun createAssociatedIdCache(prop: ImmutableProp): Cache<*, *>? =\n                        ChainCacheBuilder<Any, Any>()\n                            .add(\n                                // highlight-next-line\n                                RedisHashBinder(\n                                    redisTemplate, \n                                    objectMapper, \n                                    prop, \n                                    Duration.ofMinutes(5)\n                                )\n                            )\n                            .build()\n\n                    // One-to-many/many-to-many association cache, support parameterization \n                    override fun createAssociatedIdListCache(prop: ImmutableProp): Cache<*, List<*>>? =\n                        ChainCacheBuilder<Any, List<*>>()\n                            .add(\n                                // highlight-next-line\n                                RedisHashBinder(\n                                    redisTemplate, \n                                    objectMapper, \n                                    prop, \n                                    Duration.ofMinutes(5)\n                                )\n                            )\n                            .build()\n\n                    // Calculated property cache, support parameterization \n                    override fun createResolverCache(prop: ImmutableProp): Cache<*, *>? =\n                        ChainCacheBuilder<Any, List<*>>()\n                            .add(\n                                // highlight-next-line\n                                RedisHashBinder(\n                                    redisTemplate, \n                                    objectMapper, \n                                    prop, \n                                    Duration.ofHours(1)\n                                )\n                            )\n                            .build()\n                }\n            )\n        }\n        ...Omit other configuration...\n    }\n")))),(0,r.kt)("h2",{id:"consistency-for-parameterized-caches"},"Consistency for Parameterized Caches"),(0,r.kt)("p",null,"for parameterized association caches, the cached results are not only affected by relationships between tables, but also by global filters of associated objects."),(0,r.kt)("p",null,"For ordinary filters, you can apply any SQL filter rules."),(0,r.kt)("p",null,"However, filters that support caching are different and are restricted from supporting neither table joins nor subqueries."),(0,r.kt)("p",null,"This limitation means that cacheable filters can only filter fields of the filtered table. Conversely, in addition to the relationship between the tables, only the data change of the filtered table will affect the association cache corresponding to the current filter."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"CacheableFilter"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"KCacheableFilter")," also needs to implement an ",(0,r.kt)("inlineCode",{parentName:"p"},"isAffectedBy")," method, which is used to ask whether the data change of the filtered table will affect the current filter."),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"@Component\npublic class TenantFilter implements Filter<TenantAwareProps> {\n\n    @Override\n    public boolean isAffectedBy(EntityEvent<?> e) {\n        // If the `tenant` field of the filtered table is modified, \n        // the current filter will be affected\n        return e.getChangedFieldRef(TenantAwareProps.TENANT) != null;\n    }\n\n    ...Omit other methods...\n}\n"))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Component\nclass TenantFilter(\n    ...\u5ffd\u7565\u6ce8\u5165\u4f9d\u8d56...\n) : KFilter<TenantAware> {\n\n    override fun isAffectedBy(e: EntityEvent<*>): Boolean =\n        // If the `tenant` field of the filtered table is modified, \n        // the current filter will be affected\n        e.getChangedFieldRef(TenantAware::tenant) !== null\n\n    ....Omit other methods...\n}\n")))),(0,r.kt)("p",null,"Refer to ","[External Cache - Data Consistency]","(./cache#Data Consistency), after completing the base work of data consistency, run the program, open any SQL tool, and execute"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"update book set tenant = 'b' where id = 3;\n")),(0,r.kt)("p",null,"Assuming the modified ",(0,r.kt)("inlineCode",{parentName:"p"},"Book-3")," is associated with ",(0,r.kt)("inlineCode",{parentName:"p"},"BookStore-1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Author-1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Author-2"),", you can find these output in the application log"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Delete object data from redis: [Book-3]\nDelete property data from redis: [BookStore.books-1]\nDelete property data from redis: [Author.books-1]\nDelete property data from redis: [Author.books-2]\n")),(0,r.kt)("h2",{id:"filters-and-calculated--properties"},"Filters and calculated  properties"),(0,r.kt)("p",null,"In the article ",(0,r.kt)("a",{parentName:"p",href:"./calculated-prop"},"Calculated Properties and Caching"),", we discussed how to implement calculated properties and associated caching."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"TransientResolver")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"KTransientResolver")," interface supports a method ",(0,r.kt)("inlineCode",{parentName:"p"},"getParameterMapRef()")," with return type ",(0,r.kt)("inlineCode",{parentName:"p"},"Ref<SortedMap<String, Object>>"),"."),(0,r.kt)("p",null,"This method has a default implementation and does not have to be overridden. The default behavior returns a non-null Ref, but the value inside is null."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"The ",(0,r.kt)("inlineCode",{parentName:"th"},"Ref")," returned by the ",(0,r.kt)("inlineCode",{parentName:"th"},"getParameterMapRef()")," method"),(0,r.kt)("th",{parentName:"tr",align:null},"Does the cache support parameterization"),(0,r.kt)("th",{parentName:"tr",align:null},"Final effect"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"null"),(0,r.kt)("td",{parentName:"tr",align:null},"NA"),(0,r.kt)("td",{parentName:"tr",align:null},"Do not use calculated cache")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Ref")," itself is not null, but the internal map is null or has a length of 0"),(0,r.kt)("td",{parentName:"tr",align:null},"NA"),(0,r.kt)("td",{parentName:"tr",align:null},"Use calculated cache, cache the calculation result corresponding to the current parameterless filter")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Ref"),"\u5185\u90e8\u7684map\u957f\u5ea6\u975e0"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"Do not use calculated cache")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Ref"),"\u5185\u90e8\u7684map\u957f\u5ea6\u975e0"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"Use calculated cache, cache the calculation result corresponding to the current parameterized filter")))),(0,r.kt)("p",null,"For the last two cases, the calculated cache might look like this"),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"key"),(0,r.kt)("th",null,"hash"),(0,r.kt)("th",null,"value"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",{rowspan:"3"},"BookStore.avgPrice-1"),(0,r.kt)("td",null,"{}"),(0,r.kt)("td",null,"67.33333")),(0,r.kt)("tr",null,(0,r.kt)("td",null,'{"tenant":"a"}'),(0,r.kt)("td",null,"66.5")),(0,r.kt)("tr",null,(0,r.kt)("td",null,'{"tenant":"b"}'),(0,r.kt)("td",null,"69")),(0,r.kt)("tr",null,(0,r.kt)("td",{rowspan:"3"},"BookStore.avgPrice-2"),(0,r.kt)("td",null,"{}"),(0,r.kt)("td",null,"39.4")),(0,r.kt)("tr",null,(0,r.kt)("td",null,'{"tenant":"a"}'),(0,r.kt)("td",null,"39.75")),(0,r.kt)("tr",null,(0,r.kt)("td",null,'{"tenant":"b"}'),(0,r.kt)("td",null,"38.7")))),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookStoreAvgPriceResolver.java"',title:'"BookStoreAvgPriceResolver.java"'},'public class BookStoreAvgPriceResolver \nimplements TransientResolver<Long, BigDecimal> {\n\n    private final JSqlClient sqlClient;\n\n    public BookStoreAvgPriceResolver(JSqlClient sqlClient) {\n        \n        this.sqlClient = sqlClient;\n\n        // 1. Check whether the association when `BookStore.books` is changed\n        sqlClient.getTriggers().addAssociationListener(\n            // highlight-next-line\n            BookStoreProps.BOOKS, // \u03b1\n            e -> {\n                ...Compared to the example in the article...\n                ..."Calculated property and its cache", ...\n                ...the logic has not changed, omit...\n            }\n        );\n        sqlClient.getTriggers().addEntityListener(\n            Book.class, \n            e -> {\n                ...Compared to the example in the article...\n                ..."Calculated property and its cache", ...\n                ...the logic has not changed, omit...\n            }\n        );\n    }\n\n    @Override\n    public Ref<SortedMap<String, Object>> getParameterMapRef() {\n        return sqlClient\n            .filters\n            // highlight-next-line\n            .getTargetParameterMapRef(BookStoreProps.BOOKS) // \u03b2\n    }\n\n    @Override\n    public Map<Long, BigDecimal> resolve(\n            Collection<Long> ids, \n            Connection con\n    ) {\n        ...omit calculation code...\n    }\n}\n'))),(0,r.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookStoreAvgPriceResolver.kt"',title:'"BookStoreAvgPriceResolver.kt"'},'class BookStoreAvgPriceResolver(\n    private val sqlClient: KSqlClient\n) : KTransientResolver<Long, BigDecimal> {\n\n    init {\n        // 1. Check whether the association `BookStore.books` is changed.\n        sqlClient\n            .triggers\n            // highlight-next-line\n            .addAssociationListener(BookStore::books) { // \u03b1\n                ...Compared to the example in the article...\n                ..."Calculated property and its cache", ...\n                ...the logic has not changed, omit...\n            }\n\n        sqlClient.triggers.addEntityListener(Book::class) {\n            ...Compared to the example in the article...\n                ..."Calculated property and its cache", ...\n                ...the logic has not changed, omit...\n        }\n    }\n\n    override fun getParameterMapRef(): Ref<SortedMap<String, Any>?>? =\n        sqlClient\n            .filters\n            // highlight-next-line\n            .getTargetParameterMapRef(BookStore::books) // \u03b2\n\n    override fun resolve(\n        ids: Collection<Long>,\n        con: Connection\n    ): Map<Long, BigDecimal> =\n        ... omit calculation code ...\n}\n')))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u03b1:    Monitor the change of one-to-many association ",(0,r.kt)("inlineCode",{parentName:"p"},"BookStore.books"),", the following two cases will trigger this event"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"  - The foreign key `STORE_ID` of the `BOOK` table was changed\n  - The `TENANT` field of the `BOOK` table is changed\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u03b2:    The associated type of one-to-many association ",(0,r.kt)("inlineCode",{parentName:"p"},"Book.books")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"Book"),", returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"Ref")," wrapper for the parameters of the filter of ",(0,r.kt)("inlineCode",{parentName:"p"},"Book")," type"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"  - If the `Book` class has no filter, the returned `Ref` itself is not null, but the internal map is null\n  - If the `Book` class has a filter but the filter does not support cache, return null\n  - If the `Book` class has a filter and the filter supports cache, the returned `Ref` is not null and its internal map is the filter parameters\n")))),(0,r.kt)("p",null,"Modifying the ",(0,r.kt)("inlineCode",{parentName:"p"},"TENANT_ID")," field of the ",(0,r.kt)("inlineCode",{parentName:"p"},"BOOK")," table will affect the cache of the one-to-many association ",(0,r.kt)("inlineCode",{parentName:"p"},"BookStore.books"),", which will further affect the cache of the calculated property ",(0,r.kt)("inlineCode",{parentName:"p"},"BookStore.avgPrice"),"."),(0,r.kt)("p",null,"Refer to ","[External Cache - Data Consistency]","(./cache#Data Consistency), after completing the base work of data consistency, run the program, open any SQL tool, and execute"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"update book set tenant = 'b' where id = 3;\n")),(0,r.kt)("p",null,"Assuming the modified ",(0,r.kt)("inlineCode",{parentName:"p"},"Book-3")," is associated with ",(0,r.kt)("inlineCode",{parentName:"p"},"BookStore-1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Author-1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Author-2"),", you can find these output in the application log"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"Delete object data from redis: [Book-3]\nDelete property data from redis: [BookStore.books-1]\n// highlight-next-line\nDelete property data from redis: [BookStore.avgPrice-1]\nDelete property data from redis: [Author.books-1]\nDelete property data from redis: [Author.books-2]\n")))}k.isMDXComponent=!0}}]);