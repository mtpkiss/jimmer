"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[5426],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var r=a.createContext({}),p=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(r.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,r=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(n),u=i,k=c["".concat(r,".").concat(u)]||c[u]||m[u]||o;return n?a.createElement(k,l(l({ref:t},d),{},{components:n})):a.createElement(k,l({ref:t},d))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=c;var s={};for(var r in t)hasOwnProperty.call(t,r)&&(s[r]=t[r]);s.originalType=e,s.mdxType="string"==typeof e?e:i,l[1]=s;for(var p=2;p<o;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},5162:function(e,t,n){n.d(t,{Z:function(){return l}});var a=n(7294),i=n(4334),o="tabItem_Ymn6";function l(e){var t=e.children,n=e.hidden,l=e.className;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(o,l),hidden:n},t)}},5488:function(e,t,n){n.d(t,{Z:function(){return u}});var a=n(3117),i=n(7294),o=n(4334),l=n(2389),s=n(7392),r=n(7094),p=n(2466),d="tabList__CuJ",m="tabItem_LNqP";function c(e){var t,n,l=e.lazy,c=e.block,u=e.defaultValue,k=e.values,h=e.groupId,b=e.className,g=i.Children.map(e.children,(function(e){if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),f=null!=k?k:g.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),N=(0,s.l)(f,(function(e,t){return e.value===t.value}));if(N.length>0)throw new Error('Docusaurus error: Duplicate values "'+N.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var y=null===u?u:null!=(t=null!=u?u:null==(n=g.find((function(e){return e.props.default})))?void 0:n.props.value)?t:g[0].props.value;if(null!==y&&!f.some((function(e){return e.value===y})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+y+'" but none of its children has the corresponding value. Available values are: '+f.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var v=(0,r.U)(),w=v.tabGroupChoices,T=v.setTabGroupChoices,I=(0,i.useState)(y),j=I[0],C=I[1],O=[],A=(0,p.o5)().blockElementScrollPositionUntilNextRender;if(null!=h){var B=w[h];null!=B&&B!==j&&f.some((function(e){return e.value===B}))&&C(B)}var x=function(e){var t=e.currentTarget,n=O.indexOf(t),a=f[n].value;a!==j&&(A(t),C(a),null!=h&&T(h,String(a)))},S=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a,i=O.indexOf(e.currentTarget)+1;n=null!=(a=O[i])?a:O[0];break;case"ArrowLeft":var o,l=O.indexOf(e.currentTarget)-1;n=null!=(o=O[l])?o:O[O.length-1]}null==(t=n)||t.focus()};return i.createElement("div",{className:(0,o.Z)("tabs-container",d)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":c},b)},f.map((function(e){var t=e.value,n=e.label,l=e.attributes;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:j===t?0:-1,"aria-selected":j===t,key:t,ref:function(e){return O.push(e)},onKeyDown:S,onFocus:x,onClick:x},l,{className:(0,o.Z)("tabs__item",m,null==l?void 0:l.className,{"tabs__item--active":j===t})}),null!=n?n:t)}))),l?(0,i.cloneElement)(g.filter((function(e){return e.props.value===j}))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},g.map((function(e,t){return(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==j})}))))}function u(e){var t=(0,l.Z)();return i.createElement(c,(0,a.Z)({key:String(t)},e))}},8505:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return d},default:function(){return h},frontMatter:function(){return p},metadata:function(){return m},toc:function(){return u}});var a=n(3117),i=n(102),o=(n(7294),n(3905)),l=n(5488),s=n(5162),r=["components"],p={sidebar_position:3,title:"Save command"},d=void 0,m={unversionedId:"jimmer-sql/mutation/save-command",id:"jimmer-sql/mutation/save-command",title:"Save command",description:"If GraphQL is a powerful dynamic tree output solution, then the save command is a dynamic tree input solution.",source:"@site/docs/jimmer-sql/mutation/save-command.mdx",sourceDirName:"jimmer-sql/mutation",slug:"/jimmer-sql/mutation/save-command",permalink:"/jimmer/docs/jimmer-sql/mutation/save-command",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer/tree/main/doc/docs/jimmer-sql/mutation/save-command.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Save command"},sidebar:"tutorialSidebar",previous:{title:"Delete statement",permalink:"/jimmer/docs/jimmer-sql/mutation/delete-statement"},next:{title:"Generate static types",permalink:"/jimmer/docs/jimmer-sql/mutation/static"}},c={},u=[{value:"The scope of this article",id:"the-scope-of-this-article",level:2},{value:"Save mode",id:"save-mode",level:2},{value:"upsert",id:"upsert",level:3},{value:"insert-only",id:"insert-only",level:3},{value:"udpate-only",id:"udpate-only",level:3},{value:"Business primary key",id:"business-primary-key",level:2},{value:"Statically define business primary key",id:"statically-define-business-primary-key",level:3},{value:"Save object without id",id:"save-object-without-id",level:3},{value:"Dynamically define business primary key",id:"dynamically-define-business-primary-key",level:3},{value:"Partial object",id:"partial-object",level:2},{value:"Optimistic locking",id:"optimistic-locking",level:2},{value:"Save association",id:"save-association",level:2},{value:"Basic usage",id:"basic-usage",level:3},{value:"Abandoned by parent object",id:"abandoned-by-parent-object",level:3},{value:"Save associations and associated objects",id:"save-associations-and-associated-objects",level:2}],k={toc:u};function h(e){var t=e.components,p=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},k,p,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"If GraphQL is a powerful dynamic tree output solution, then the save command is a dynamic tree input solution.")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"save",src:n(8411).Z,width:"1473",height:"1036"})),(0,o.kt)("p",null,"The Save command is used to save object tree of arbitrary breadth and depth."),(0,o.kt)("p",null,"Most ORM frameworks let developers declare static cascade saving configurations on entity types, and use the configuration as  guide for saving multiple objects."),(0,o.kt)("p",null,"jimmer-sql uses a completely different approach, using the dynamic nature of jimmer-core immutable objects themselves, to describe  object tree with arbitrary complexity to be saved, such as"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Partial object"),(0,o.kt)("li",{parentName:"ul"},"Complete object"),(0,o.kt)("li",{parentName:"ul"},"Shallower object tree"),(0,o.kt)("li",{parentName:"ul"},"Deeper object tree")),(0,o.kt)("p",null,"All of the above situations can be easily expressed by the dynamic immutable objects."),(0,o.kt)("p",null,"Therefore, jimmer-sql does not need any static cascade saving configuration of entity type metadata, and all information is dynamically expressed through the object tree itself."),(0,o.kt)("h2",{id:"the-scope-of-this-article"},"The scope of this article"),(0,o.kt)("p",null,"Jimmer supports ",(0,o.kt)("a",{parentName:"p",href:"../advanced/trigger"},"trigger"),", which is divided into binlog trigger and transaction trigger."),(0,o.kt)("p",null,"Using transaction triggers will cause jimmer's modification operations to generate more and more complete queries to simulate triggers."),(0,o.kt)("p",null,"Several scenarios have been discussed in this article, and the generated SQL will be discussed for each scenario, all on the premise that transaction triggers are not used."),(0,o.kt)("h2",{id:"save-mode"},"Save mode"),(0,o.kt)("h3",{id:"upsert"},"upsert"),(0,o.kt)("p",null,"By default, the save command performs an upsert operation, that means update or insert."),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'SimpleSaveResult<Book> result = sqlClient\n    .getEntities()\n    .save(\n        BookDraft.$.produce(book -> {\n            book\n                .setId(1L)\n                .setName("SpringBoot in Action")\n                .setEdition(1)\n                .setPrice(new BigDecimal("44.99"));\n        })\n    );\nSystem.out.println("Affected row count: " + result.getTotalAffectedRowCount());\n'))),(0,o.kt)(s.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val result = sqlClient\n    .entities\n    .save(\n        new(Book::class).by { \n            id = 1L\n            name = "SpringBoot in Action"\n            edition = 1\n            price = BigDecimal("44.99")\n        }\n    )\nprintln("Affected row count: " + result.totalAffectedRowCount)\n')))),(0,o.kt)("p",null,"Assuming that the specified object does not exist in the database, these two SQL statement are generated"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION \nfrom BOOK as tb_1_ \nwhere tb_1_.ID = ?\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"insert into BOOK(ID, NAME, EDITION, PRICE) \nvalues(?, ?, ?, ?);\n")))),(0,o.kt)("p",null,"The first sentence of SQL asks whether the specified object exists in the database. If it does not exist, the second SQL is an insert statement; otherwise, the second SQL is an update statement."),(0,o.kt)("a",{name:"why_select_name_and_edition"},"As for the reasons why `NAME` and `EDITION` appear in the query statement, I will discuss them later, so please ignore them here."),(0,o.kt)("h3",{id:"insert-only"},"insert-only"),(0,o.kt)("p",null,"In the previous case, a query was used to determine whether the ",(0,o.kt)("inlineCode",{parentName:"p"},"save")," operation should execute ",(0,o.kt)("inlineCode",{parentName:"p"},"insert")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"update"),". This is the default behavior of the save command."),(0,o.kt)("p",null,"This behavior, while convenient to use, introduces an extra ",(0,o.kt)("inlineCode",{parentName:"p"},"select")," statement, which has a performance impact."),(0,o.kt)("p",null,"Sometimes, developers know that the operation they want to perform is ",(0,o.kt)("inlineCode",{parentName:"p"},"insert"),", and automatic judgment is not need so that performance can be imporoved."),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'SimpleSaveResult<Book> result = sqlClient\n    .getEntities()\n    .saveCommand(\n        BookDraft.$.produce(book -> {\n            book\n                .setId(100L)\n                .setName("SpringBoot in Action")\n                .setEdition(1)\n                .setPrice(new BigDecimal("44.99"));\n        })\n    )\n    .configure(it -> \n        // highlight-next-line\n        it.setMode(SaveMode.INSERT_ONLY)\n    )\n    .execute();\nSystem.out.println("Affected row count: " + result.getTotalAffectedRowCount());\n'))),(0,o.kt)(s.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val result = sqlClient\n    .entities\n    .save(\n        new(Book::class).by {\n            id = 100L\n            name = "SpringBoot in Action"\n            edition = 1\n            price = BigDecimal("44.99")\n        }\n    ) {\n        // highlight-next-line\n        setMode(SaveMode.INSERT_ONLY)\n    }\nprintln("Affected row count: " + result.totalAffectedRowCount)\n')))),(0,o.kt)("p",null,"Here, we configure the save command to ",(0,o.kt)("inlineCode",{parentName:"p"},"insert-only")," mode through ",(0,o.kt)("inlineCode",{parentName:"p"},"setMode(SaveMode.INSERT_ONLY)"),", so only one SQL statement for inserting data will be generated"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"insert into BOOK(ID, NAME, EDITION, PRICE) \n    values(?, ?, ?, ?);\n")),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},"sqlClient.getEntities().save(someObj);\n")),(0,o.kt)("p",{parentName:"admonition"},"and"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},"sqlClient.getEntities().saveCommand(someObj).execute();\n")),(0,o.kt)("p",{parentName:"admonition"},"completely equivalent."),(0,o.kt)("p",{parentName:"admonition"},"The first way is concise, the second way is configurable.")),(0,o.kt)("h3",{id:"udpate-only"},"udpate-only"),(0,o.kt)("p",null,"In the same way, if the developer knows that the operation to be performed must be ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," rather than ",(0,o.kt)("inlineCode",{parentName:"p"},"insert"),", the ",(0,o.kt)("inlineCode",{parentName:"p"},"update-only")," mode can be used"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'SimpleSaveResult<Book> result = sqlClient\n    .getEntities()\n    .saveCommand(\n        BookDraft.$.produce(book -> {\n            book\n                .setId(1L)\n                .setName("SpringBoot in Action")\n                .setEdition(1)\n                .setPrice(new BigDecimal("44.99"));\n        })\n    )\n    .configure(it -> \n        // highlight-next-line\n        it.setMode(SaveMode.UPDATE_ONLY)\n    )\n    .execute();\nSystem.out.println("Affected row count: " + result.getTotalAffectedRowCount());\n'))),(0,o.kt)(s.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val result = sqlClient\n    .entities\n    .save(\n        new(Book::class).by {\n            id = 1L\n            name = "SpringBoot in Action"\n            edition = 1\n            price = BigDecimal("44.99")\n        }\n    ) {\n        // highlight-next-line\n        setMode(SaveMode.UPDATE_ONLY)\n    }\nprintln("Affected row count: " + result.totalAffectedRowCount)\n')))),(0,o.kt)("p",null,"Only one SQL statement will be generated."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"update BOOK \nset \n    NAME = ?, \n    EDITION = ?, \n    PRICE = ? \nwhere \n    ID = ?\n")),(0,o.kt)("h2",{id:"business-primary-key"},"Business primary key"),(0,o.kt)("h3",{id:"statically-define-business-primary-key"},"Statically define business primary key"),(0,o.kt)("p",null,"At ",(0,o.kt)("a",{parentName:"p",href:"../basic/mapping#key"},"Mapping/@key"),", we explained the @Key annotation."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"@Id: Technical primary key, which often stores some unique data that has no business meaning, such as automatic numbering, serial value, UUID, snowflake id. But it's simple enough to minimize table joins and improve performance.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"@Key: Business primary key, unique data with business significance, and is often used in conjunction with multiple columns. But it is relatively complex and does not directly participate in table join operations."))),(0,o.kt)("p",null,"Specify the business primary key for the ",(0,o.kt)("inlineCode",{parentName:"p"},"Book")," type"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Book.java"',title:'"Book.java"'},"@Entity\npublic interface Book {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    long id();\n\n    // highlight-next-line\n    @Key\n    String name();\n\n    // highlight-next-line\n    @Key\n    int edition();\n\n    ...Omit other code...\n}\n"))),(0,o.kt)(s.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="Book.kt"',title:'"Book.kt"'},"@Entity\ninterface Book {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    val id: Long\n\n    // highlight-next-line\n    @Key\n    val name: String\n\n    // highlight-next-line\n    @Key\n    val edition: Int\n\n    ...Omit other code...\n}\n")))),(0,o.kt)("p",null,"A ",(0,o.kt)("a",{parentName:"p",href:"#why_select_name_and_edition"},"question")," was raised earlier, and it can be answered here."),(0,o.kt)("p",null,"If a business primary key is configured for the entity interface, the save command can accept objects without id, that is, objects whose id property is not set."),(0,o.kt)("p",null,"For the save command in upsert mode"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"If the id of the object to be saved is specified, the save command queries whether the saved object exists in the database according to the id property to determine whether the subsequent operation is insert or update. Just like we demonstrated earlier.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"If the id of the saved object is not specified, determine whether the business primary key is configured"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"If the business primary key is configured, check whether the saved object exists in the database according to the properties of the business primary key to determine whether the subsequent operation is ",(0,o.kt)("inlineCode",{parentName:"li"},"insert")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"update"),"."),(0,o.kt)("li",{parentName:"ul"},"Otherwise, throw an exception.")))),(0,o.kt)("h3",{id:"save-object-without-id"},"Save object without id"),(0,o.kt)("p",null,"Let's see an example of saving an object without id"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'SimpleSaveResult<Book> result = sqlClient\n    .getEntities()\n    .save(\n        BookDraft.$.produce(book -> {\n            book\n                // No id here\n                .setName("SpringBoot in Action")\n                .setEdition(1)\n                .setPrice(new BigDecimal("44.99"));\n        })\n    );\nSystem.out.println(\n    "Original entity: " + result.getOriginalEntity()\n);\nSystem.out.println(\n    "Modified entity: " + result.getModifiedEntity()\n);\n'))),(0,o.kt)(s.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val result = sqlClient\n    .entities\n    .save(\n        new(Book::class).by {\n            // No id here\n            name = "SpringBoot in Action"\n            edition = 1\n            price = BigDecimal("44.99")\n        }\n    )\nprintln(\n    "Original entity: " + result.originalEntity\n)\nprintln(\n    "Modified entity: " + result.modifiedEntity\n)\n')))),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Book")," object to be saved has no id, so query whether the saved object exists in the database according to the business primary key ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"edition"),"."),(0,o.kt)("p",null,"Assuming that the above code eventually leads to the ",(0,o.kt)("inlineCode",{parentName:"p"},"insert")," operation, the two SQL statements generated are as follows"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION \nfrom BOOK as tb_1_ \nwhere\n/* highlight-start */ \n    tb_1_.NAME = ? \nand \n    tb_1_.EDITION = ?\n/* highlight-end */\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"insert into BOOK(ID, NAME, EDITION, PRICE) \nvalues(?, ?, ?, ?)\n")))),(0,o.kt)("p",null,"To insert an object without an id, you must configure ",(0,o.kt)("inlineCode",{parentName:"p"},"@GeneratedValue")," for the id property, so that jimmer-sql can automatically generate an id for it."),(0,o.kt)("p",null,"Finally, we can get the automatically allocated id. The print result of the above code is as follows (the original output is compact, it is formatted here for easy reading):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'Original entity: {\n    "name":"SpringBoot in Action",\n    "edition":1,\n    "price":44.99\n}\nModified entity: {\n    /* highlight-next-line */\n    "id":100,\n    "name":"SpringBoot in Action",\n    "edition":1,\n    "price":44.99\n}\n')),(0,o.kt)("p",null,"The save command return object whose type is ",(0,o.kt)("inlineCode",{parentName:"p"},"SimpleSaveResult<E>"),", it contains two read-only properties"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"originalEntity"),": The object passed in by user.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"modifiedEntity"),": The latest state of the saved object after the save command is executed."),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"If the save process involves some automatic object changes, such as: automatic id allocation, automatic increase of optimistic lock version number, then jimmer-sql will make ",(0,o.kt)("inlineCode",{parentName:"p"},"modifiedEntity")," point to a new object. Users can get the latest status of the data.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Otherwise, ",(0,o.kt)("inlineCode",{parentName:"p"},"modifiedEntity")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"originalEntity")," are same object, they share the old object passed by the user."))))),(0,o.kt)("h3",{id:"dynamically-define-business-primary-key"},"Dynamically define business primary key"),(0,o.kt)("p",null,"In the previous example, we used the annotation ",(0,o.kt)("inlineCode",{parentName:"p"},"@Key")," to configure the business primary key statically. In fact, we can also dynamically set the business primary key for the save command."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"This is useful if your project needs to define different business primary keys for the same entity type for different business scenarios.")),(0,o.kt)("p",null,"An example of dynamically defining a business primary key"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'SimpleSaveResult<Book> result = sqlClient\n    .getEntities()\n    .saveCommand(\n        BookDraft.$.produce(book -> {\n            book\n                    .setName("SpringBoot in Action")\n                    .setEdition(1)\n                    .setPrice(new BigDecimal("44.99"));\n        })\n    )\n    .configure(\n        // highlight-next-line\n        it -> it.setKeyProps(BookTable.class, keyProps -> {\n            keyProps\n                    .add(BookProps.NAME)\n                    .add(BookProps.EDITION);\n        })\n    )\n    .execute();\n'))),(0,o.kt)(s.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val result = sqlClient\n    .entities\n    .save(\n        new(Book::class).by {\n            // No id here\n            name = "SpringBoot in Action"\n            edition = 1\n            price = BigDecimal("44.99")\n        }\n    ) {\n        // highlight-next-line\n        setKeyProps(Book::name, Book::price)\n    }\nprintln(result)\n')))),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"If both the dynamic business primary key is configured for the save command, and the static business primary key is configured for the entity interface, the dynamic configuration takes precedence.")),(0,o.kt)("h2",{id:"partial-object"},"Partial object"),(0,o.kt)("p",null,"The dynamic nature of jimmer-core immutable objects can lead to partial objects, that is, objects with unspecified properties."),(0,o.kt)("p",null,"The partial object is important for the save command, and different data shape result in different behaviors."),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'List<BookStore> stores = Arrays.asList(\n    BookStoreDraft.$.produce(store -> {\n        store\n            .setId(1L)\n            .setName("O\'REILLY+");\n            // No website here\n    }),\n    BookStoreDraft.$.produce(store -> {\n        store\n            .setId(2L)\n            .setName("MANNING+")\n            .setWebsite(null);\n            // Null website here\n    })\n);\nsqlClient\n    .getEntities()\n    .batchSaveCommand(stores)\n    .configure(it -> it.setMode(SaveMode.UPDATE_ONLY))\n    .execute();\n'))),(0,o.kt)(s.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val stores = listOf(\n    new(BookStore::class).by {\n        id = 1L\n        name = "O\'REILLY+"\n        // No website here\n    },\n    new(BookStore::class).by {\n        id = 2L\n        name = "MANNING+"\n        website = null\n        // Null website here\n    }\n)\nsqlClient\n    .entities\n    .batchSave(stores) {\n        setMode(SaveMode.UPDATE_ONLY)\n    }\n')))),(0,o.kt)("p",null,"Here, we use the method ",(0,o.kt)("inlineCode",{parentName:"p"},"batchSaveCommand")," to save two ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore")," objects."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The property ",(0,o.kt)("inlineCode",{parentName:"p"},"website")," of the first object is not specified.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The property ",(0,o.kt)("inlineCode",{parentName:"p"},"website")," of the second object is specified as null."))),(0,o.kt)("p",null,"The two generated SQL statements are"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Save object whose ",(0,o.kt)("inlineCode",{parentName:"p"},"website")," property is not specified"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"update BOOK_STORE \n// highlight-next-line\nset NAME = ? \nwhere ID = ?\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Save a object whose ",(0,o.kt)("inlineCode",{parentName:"p"},"website")," property is specified as null"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"update BOOK_STORE \n// highlight-next-line\nset NAME = ?, WEBSITE = ? \nwhere ID = ?\n")))),(0,o.kt)("p",null,"We see that the two SQL statements are very different. Not setting and setting to null are two completely different things."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"The partial object is very important for the save command, and most of the functions of the save command are finely controlled by the object shape."),(0,o.kt)("p",{parentName:"admonition"},"Relying on the incompleteness of the object to decide how to save arbitrarily complex object tree (the knowledge related to saving associations and associated objects will be discussed later), rather than relying on the static cascade save configuration on the entity type. This is the essential difference between jimmer-sql and other ORMs in data preservation.")),(0,o.kt)("h2",{id:"optimistic-locking"},"Optimistic locking"),(0,o.kt)("p",null,"To use optimistic locking, first configure it in the entity interface"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookStore.java"',title:'"BookStore.java"'},"@Entity\npublic interface BookStore {\n\n    @Version\n    int version();\n\n    ... omit other properties ...\n}\n"))),(0,o.kt)(s.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookStore.kt"',title:'"BookStore.kt"'},"@Entity\ninterface BookStore {\n\n    @Version\n    val version: Int\n\n    ... omit other properties ...\n}\n")))),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"For the ",(0,o.kt)("inlineCode",{parentName:"p"},"insert")," operation (whether manually specified or automatically determined), it is allowed to not specify the optimistic lock property, jimmer-sql uses 0 as its default value. Of course, if the developer specifies it, the specified value will be used.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"For the ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," operation (whether manually specified or automatically determined), the optimistic lock field must be specified, otherwise an exception will be thrown.")))),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'SimpleSaveResult<BookStore> result = sqlClient\n    .getEntities()\n    .saveCommand(\n        BookStoreDraft.$.produce(store -> {\n            store\n                .setId(2)\n                .setWebsite("http://www.manning.com")\n                // highlight-next-line\n                .setVersion(0);\n        })\n    )\n    .configure(it -> it.setMode(SaveMode.UPDATE_ONLY))\n    .execute();\nSystem.out.println(\n    "Original entity: " + result.getOriginalEntity()\n);\nSystem.out.println(\n    "Modified entity: " + result.getModifiedEntity()\n);\n'))),(0,o.kt)(s.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val result = sqlClient\n    .entities\n    .save(\n        new(BookStore::class).by {\n            id = 2L\n            website = "http://www.manning.com"\n            // highlight-next-line\n            version = 0\n        }\n    ) {\n        setMode(SaveMode.UPDATE_ONLY) \n    }\nprintln(\n    "Original entity: " + result.originalEntity\n)\nprintln(\n    "Modified entity: " + result.modifiedEntity\n)\n')))),(0,o.kt)("p",null,"The generated SQL statement is as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"update BOOK_STORE \nset \n    /* highlight-next-line */\n    VERSION = VERSION + 1 \nwhere \n    ID = ? \nand \n    /* highlight-next-line */\n    VERSION = ?\n")),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"If the affected row count is 0, it will throw an exception of type ",(0,o.kt)("inlineCode",{parentName:"p"},"org.babyfish.jimmer.sql.OptimisticLockException"),".")),(0,o.kt)("p",null,"If the versions match and no exception occurs, the output of the above code is (the original output is compact, formatted here for readability):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'Original entity: {\n    "id":2,\n    "website":"http://www.manning.com",\n    "version":0\n}\nModified entity: {\n    "id":2,\n    "website":"http://www.manning.com",\n    /* highlight-next-line */\n    "version":1\n}\n')),(0,o.kt)("p",null,"As you can see, the ",(0,o.kt)("inlineCode",{parentName:"p"},"version")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"result.modifiedEntity")," has been changed."),(0,o.kt)("h2",{id:"save-association"},"Save association"),(0,o.kt)("p",null,"We can also specify association properties for object to be saved in two ways"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Only the id of the associated object(s) is set: this means that only the association itself need to be saved, such as foreign keys, middle table records; but the association object will not be changed.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Non-id properties of the associated object(s) are set: this means that not only the association itself, but also the associated object will be saved."))),(0,o.kt)("p",null,"This section focuses on the first usage, saving only the association itself; the second usage is covered in the next section."),(0,o.kt)("h3",{id:"basic-usage"},"Basic usage"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'SimpleSaveResult<Book> result = sqlClient\n    .getEntities()\n    .save(\n        BookDraft.$.produce(book -> {\n            book\n                .setName("SpringBoot in Action")\n                .setEdition(1)\n                .setPrice(new BigDecimal("44.99"))\n                // highlight-next-line\n                .applyStore(store -> \n                    store.setId(2L)\n                )\n                // highlight-next-line\n                .addIntoAuthors(author -> \n                    author.setId(2L)\n                )\n                // highlight-next-line\n                .addIntoAuthors(author -> \n                    author.setId(3L)\n                );\n        })\n    );\nSystem.out.println("Affected row counts");\nSystem.out.println(\n    "\\ttotal: " + result.getTotalAffectedRowCount()\n);\nSystem.out.println(\n    "\\tBOOK: " +\n        result.getAffectedRowCount(\n            AffectedTable.of(Book.class)\n        )\n);\nSystem.out.println(\n    "\\tBOOK_AUTHOR_MAPPING: " +\n        result.getAffectedRowCount(\n            AffectedTable.of(BookProps.AUTHORS)\n        )\n);\n'))),(0,o.kt)(s.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val result = sqlClient\n    .entities\n    .save(\n        new(Book::class).by {\n            name = "SpringBoot in Action"\n            edition = 1\n            price = BigDecimal("44.99")\n            // highlight-next-line\n            store().apply {\n                id = 2L\n            }\n            // highlight-next-line\n            authors().addBy { \n                id = 2L\n            }\n            // highlight-next-line\n            authors().addBy { \n                id = 3L\n            }\n        }\n    )\nprintln("Affected row counts")\nprintln(\n    "\\ttotal: ${result.totalAffectedRowCount}"\n)\nprintln(\n    "\\tBOOK: ${result.affectedRowCount(Book::class)}"\n)\nprintln(\n    "\\tBOOK_AUTHOR_MAPPING: ${\n        result.affectedRowCount(Book::authors)\n    }"\n)\n')))),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Here, the many-to-one property ",(0,o.kt)("inlineCode",{parentName:"p"},"store")," and then many-to-many property ",(0,o.kt)("inlineCode",{parentName:"p"},"authors")," of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Book")," object has been set, but the all associated objects only has ",(0,o.kt)("inlineCode",{parentName:"p"},"id"),"."),(0,o.kt)("p",{parentName:"admonition"},"Such usage means that only the association itself is saved, the foreign key ",(0,o.kt)("inlineCode",{parentName:"p"},"STORE_ID")," of the current table may be modified, the middle table ",(0,o.kt)("inlineCode",{parentName:"p"},"BOOK_AUTHOR_MAPPING")," between the current table and the associated object may be modified, but the entity tables mapped by the associated objects, ",(0,o.kt)("inlineCode",{parentName:"p"},"BOOK_STORE")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"AUTHOR"),", will not be modified."),(0,o.kt)("p",{parentName:"admonition"},"For this usage, the user must ensure that the id of all associated objects must exists in the database; otherwise, the database will report an error due to referential integrity violation. That is, invalid associated object ids are not accepted.")),(0,o.kt)("p",null,"The generated SQL statement is as follow"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Determine if the book to save already exists"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION \nfrom BOOK as tb_1_ \nwhere tb_1_.NAME = ? and tb_1_.EDITION = ?\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"There are two possibilities"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"If the result of the previous step does not exist, insert data",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"insert into BOOK(ID, NAME, EDITION, PRICE, STORE_ID) \nvalues(?, ?, ?, ?, ?)\n"))),(0,o.kt)("li",{parentName:"ol"},"If the result of the previous step does exist, update data",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"update BOOK \nset PRICE = ?, STORE_ID = ? \nwhere ID = ?\n"))))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"If the insert operation is performed in the previous step, no judgment is made, and data is inserted into the middle table ",(0,o.kt)("inlineCode",{parentName:"p"},"BOOK_AUTHOR_MAPPING")," of the associated property ",(0,o.kt)("inlineCode",{parentName:"p"},"Book.authors")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"insert into BOOK_AUTHOR_MAPPING(BOOK_ID, AUTHOR_ID) \nvalues (?, ?), (?, ?)\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"If the update operation was performed in the previous step"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"First, query the ",(0,o.kt)("inlineCode",{parentName:"p"},"Author")," objects associated with the current ",(0,o.kt)("inlineCode",{parentName:"p"},"Book")," object"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select AUTHOR_ID \nfrom BOOK_AUTHOR_MAPPING \nwhere BOOK_ID = ?\n")),(0,o.kt)("p",{parentName:"li"},"The collection of ids of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Author")," objects that can be found by this SQL statement is called ",(0,o.kt)("inlineCode",{parentName:"p"},"listDb"),", and the collection formed by the ids of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Author")," associated objects corresponding to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Book")," object in the user data is called ",(0,o.kt)("inlineCode",{parentName:"p"},"listUser"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Let ",(0,o.kt)("inlineCode",{parentName:"p"},"listDiff1")," = ",(0,o.kt)("inlineCode",{parentName:"p"},"listDb")," - ",(0,o.kt)("inlineCode",{parentName:"p"},"listUser"),", that is, the collection of ",(0,o.kt)("inlineCode",{parentName:"p"},"Author")," object ids that exist in the database but do not exist in the user data."),(0,o.kt)("p",{parentName:"li"},"If the length of ",(0,o.kt)("inlineCode",{parentName:"p"},"listDiff1")," is non-zero, execute the following SQL to delete unwanted associations (assuming ",(0,o.kt)("inlineCode",{parentName:"p"},"listDiff1")," has length 3):"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"delete from \nBOOK_AUTHOR_MAPPING \nwhere (BOOK_ID, AUTHOR_ID) in (\n    (?, ?), \n    (?, ?),\n    (?, ?)\n)\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Let ",(0,o.kt)("inlineCode",{parentName:"p"},"listDiff2")," = ",(0,o.kt)("inlineCode",{parentName:"p"},"listUser")," - ",(0,o.kt)("inlineCode",{parentName:"p"},"listDb"),", that is, the collection of ",(0,o.kt)("inlineCode",{parentName:"p"},"Author")," object ids that exist in the user data but do not exist in the database."),(0,o.kt)("p",{parentName:"li"},"If ",(0,o.kt)("inlineCode",{parentName:"p"},"listDiff2")," length is non-zero, execute the following SQL to insert missing associations (assuming ",(0,o.kt)("inlineCode",{parentName:"p"},"listDiff2")," length is 2):"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"insert into BOOK_AUTHOR_MAPPING(BOOK_ID, AUTHOR_ID) \nvalues (?, ?), (?, ?)\n")))))))),(0,o.kt)("p",null,"The print result of the above Java code is affected by the existing data in the database, and different situations have different print results."),(0,o.kt)("p",null,"Assuming that no other modification operations are performed except the insert operation, the print result should be as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Affected row counts\n    total: 3\n    BOOK: 1\n    BOOK_AUTHOR_MAPPING: 2\n")),(0,o.kt)("h3",{id:"abandoned-by-parent-object"},"Abandoned by parent object"),(0,o.kt)("p",null,"As can be seen from the above discussion, the save command may cause the deletion of the data in the many-to-many association based on middle table, which is a relatively simple case."),(0,o.kt)("p",null,"For one-to-one or one-to-many associations based directly on foreign keys, the situation is a bit more complicated."),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'Long bookId1 = ...;\nLong bookId2 = ...;\nsqlClient\n    .getEntities()\n    .save(\n        BookStoreDraft.$.produce(store -> {\n            store\n                .setName("TURING")\n                .addIntoBooks(\n                    book -> book.setId(bookId1)\n                )\n                .addIntoBooks(\n                    book -> book.setId(bookId2)\n                );\n        })\n    );\n'))),(0,o.kt)(s.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val bookId1 = ...\nval bookId2 = ...\nsqlClient\n    .entities\n    .save(\n        new(BookStore::class).by { \n            name = "TURING"\n            books().addBy { \n                id = bookId1\n            }\n            books().addBy { \n                id = bookId2\n            }\n        }\n    )\n')))),(0,o.kt)("p",null,"This code saves a ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore")," object whose one-to-many property ",(0,o.kt)("inlineCode",{parentName:"p"},"books")," has two ",(0,o.kt)("inlineCode",{parentName:"p"},"Book")," objects: ",(0,o.kt)("inlineCode",{parentName:"p"},"book1")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"book2"),"."),(0,o.kt)("p",null,"If it is determined that ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore")," should be inserted, everything is simple; however, if it is determined that ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore")," should be updated, it is relatively complicated."),(0,o.kt)("p",null,"Assume that the one-to-many associated property ",(0,o.kt)("inlineCode",{parentName:"p"},"books")," of the corresponding ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore")," object in the database now has 4 objects: ",(0,o.kt)("inlineCode",{parentName:"p"},"book2"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"book3"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"book4")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"book5"),"."),(0,o.kt)("p",null,"Obviously, ",(0,o.kt)("inlineCode",{parentName:"p"},"book3"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"book4")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"book5")," are discarded by the new association. But the one-to-many association ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.books")," is not based on middle table, but based on the foreign key. How will jimmer-sql drop ",(0,o.kt)("inlineCode",{parentName:"p"},"book3"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"book4")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"book5"),"?"),(0,o.kt)("p",null,"Unlike JPA, jimmer-sql does not allow direct use of ",(0,o.kt)("inlineCode",{parentName:"p"},"@OneToOne")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"@OneToMany")," for association mapping, ",(0,o.kt)("inlineCode",{parentName:"p"},"@OneToOne")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"@OneToMany")," must use the ",(0,o.kt)("inlineCode",{parentName:"p"},"mappedBy")," attribute. See ",(0,o.kt)("a",{parentName:"p",href:"../basic/mapping#onetomany"},"@OneToMany")," for more information."),(0,o.kt)("p",null,"This means, through the one-to-many association ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.books"),", jimmer-sql can definitely find the corresponding many-to-one association ",(0,o.kt)("inlineCode",{parentName:"p"},"Book.store"),"."),(0,o.kt)("p",null,"Next, jimmer-sql will look at the annotation ",(0,o.kt)("a",{parentName:"p",href:"../basic/mapping#ondissociate"},"@OnDissociate")," on the many-to-one association property ",(0,o.kt)("inlineCode",{parentName:"p"},"Book.store"),"."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"If the foreign key of ",(0,o.kt)("inlineCode",{parentName:"p"},"Book.store")," is configured as ",(0,o.kt)("inlineCode",{parentName:"p"},"SET_NULL")," by the annotated ",(0,o.kt)("a",{parentName:"p",href:"../basic/mapping#ondissociate"},"@OnDissociate"),", then execute the following SQL"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"update BOOK \nset STORE_ID = null \nwhere \n    STORE_ID = ? \nand \n    /* highlight-next-line */\n    ID not in(?, ?)\n")),(0,o.kt)("p",{parentName:"li"},"where the parameters are ",(0,o.kt)("inlineCode",{parentName:"p"},"bookId1")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"bookId2"),". After sifting through the ",(0,o.kt)("inlineCode",{parentName:"p"},"not in"),", the foreign keys of the discarded objects ",(0,o.kt)("inlineCode",{parentName:"p"},"book3"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"book4")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"book5")," are set to null.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Otherwise, first, execute"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select ID \nfrom BOOK \nwhere \n    STORE_ID = ? \nand \n    /* highlight-next-line */\n    ID not in(?, ?)\n")),(0,o.kt)("p",{parentName:"li"},"where the parameters are ",(0,o.kt)("inlineCode",{parentName:"p"},"bookId1")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"bookId2"),". After ",(0,o.kt)("inlineCode",{parentName:"p"},"not in")," screening, the ids of the discarded objects ",(0,o.kt)("inlineCode",{parentName:"p"},"book3"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"book4")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"book5")," are obtained."),(0,o.kt)("blockquote",{parentName:"li"},(0,o.kt)("p",{parentName:"blockquote"},"If the query returns no data, ignore the next steps.")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"If the foreign key of ",(0,o.kt)("inlineCode",{parentName:"p"},"Book.store")," is configured as ",(0,o.kt)("inlineCode",{parentName:"p"},"DELETE")," by the annotated ",(0,o.kt)("a",{parentName:"p",href:"../basic/mapping#ondissociate"},"@OnDissociate"),", Use ",(0,o.kt)("a",{parentName:"p",href:"./delete-command"},"delete command")," to delete these discarded objects.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Otherwise, throw an exception."))))),(0,o.kt)("p",null,"All of the situations discussed above require the developer to use the annotation ",(0,o.kt)("a",{parentName:"p",href:"../basic/mapping#ondissociate"},"@OnDissociate")," on the ",(0,o.kt)("inlineCode",{parentName:"p"},"Book.store")," property."),(0,o.kt)("p",null,"However, you can also dynamically specify the ",(0,o.kt)("inlineCode",{parentName:"p"},"dissociateAction")," configuration for the save command insteading of using the ",(0,o.kt)("a",{parentName:"p",href:"../basic/mapping#ondissociate"},"@OnDissociate")," annotation."),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'UUID bookId1 = ...;\nUUID bookId2 = ...;\nsqlClient\n    .getEntities()\n    .saveCommand(\n        BookStoreDraft.$.produce(store -> {\n            store\n                .setName("TURING")\n                .addIntoBooks(\n                    book -> book.setId(bookId1)\n                )\n                .addIntoBooks(\n                    book -> book.setId(bookId2)\n                );\n        })\n    )\n    .configure(it -> \n        // highlight-next-line\n        it.setDissociateAction(\n            BookProps.STORE,\n            DissociateAction.DELETE\n        )\n    )\n    .execute();\n'))),(0,o.kt)(s.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val bookId1 = ...\nval bookId2 = ...\nsqlClient\n    .entities\n    .save(\n        new(BookStore::class).by { \n            name = "TURING"\n            books().addBy { \n                id = bookId1\n            }\n            books().addBy { \n                id = bookId2\n            }\n        }\n    ) {\n        // highlight-next-line\n        setDissociateAction(Book::store, DissociateAction.DELETE)\n    }\n')))),(0,o.kt)("p",null,"Here, calling ",(0,o.kt)("inlineCode",{parentName:"p"},"setDissociateAction")," of save command has the same effect as statically using the annotation ",(0,o.kt)("a",{parentName:"p",href:"../basic/mapping#ondissociate"},"@OnDissociate"),"."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("ol",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"If the last parameter of the ",(0,o.kt)("inlineCode",{parentName:"p"},"setDissociateAction")," method is ",(0,o.kt)("inlineCode",{parentName:"p"},"DissociateAction.SET_NULL"),", the association property must be nullable, otherwise an exception will be thrown.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"If the delete rule is not only dynamically configured for the save command, but also statically configured in the entity interface through the annotation ",(0,o.kt)("a",{parentName:"p",href:"../basic/mapping#ondissociate"},"@OnDissociate"),", the dynamic configuration takes precedence.")))),(0,o.kt)("h2",{id:"save-associations-and-associated-objects"},"Save associations and associated objects"),(0,o.kt)("p",null,"As discussed in the previous section, our example made the associated object only have the id, so that the save command only modifies the associations, not the associated objects."),(0,o.kt)("p",null,"In fact, we can make the associated object have properties other than id, as follows"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'sqlClient\n    .getEntities()\n    .saveCommand(\n        BookDraft.$.produce(book ->\n            book\n                .setName("SpringBoot in Action")\n                .setEdition(1)\n                .setPrice(new BigDecimal("44.99"))\n                .applyStore(store ->\n                    store\n                        .setName("MANNING")\n                        .setWebsite("http://www.manning.com")\n                        .setVersion(0)\n                )\n                .addIntoAuthors(author ->\n                    author\n                        .setFirstName("Craig")\n                        .setLastName("Walls")\n                        .setGender(Gender.MALE)\n                )\n        )\n    )\n    // highlight-next-line\n    .configure(it -> it.setAutoAttachingAll())\n    .execute();\n'))),(0,o.kt)(s.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'sqlClient\n    .entities\n    .save(\n        new(Book::class).by { \n            name = "SpringBoot in Action"\n            edition = 1\n            price = BigDecimal("44.99")\n            store().apply { \n                name = "MANNING"\n                website = "http://www.manning.com"\n                version = 0\n            }\n            authors().addBy {\n                firstName = "Craig"\n                lastName = "Walls"\n                gender = Gender.MALE\n            }\n        }\n    ) {\n        // highlight-next-line\n        setAutoAttachingAll()\n    }\n')))),(0,o.kt)("p",null,"For such an operation, the generated SQL varies with the state of the database. Listing the possibilities would result in tedious content that would consume a lot of lines of this document. Therefore, only a textual discussion is given here."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Since any properties can be specified for the associated objects, of course, it also includes the deeper association properties of the associated objects. In this way, it can be continuously nested to form an object tree of any depth (for the sake of space, this example does not show the deep nesting)")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"All the knowledge presented earlier except ",(0,o.kt)("a",{parentName:"p",href:"#save-mode"},"save mode")," in this section is valid for this use case. All functions can be applied recursively to all levels."))),(0,o.kt)("p",null,"Next, focus on ",(0,o.kt)("inlineCode",{parentName:"p"},"setAutoAttachingAll()")," above."),(0,o.kt)("p",null,"For root object, the save mode is controlled by the developer, which can be ",(0,o.kt)("inlineCode",{parentName:"p"},"UPSERT"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"INSERT_ONLY"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"UPDATE_ONLY"),". where ",(0,o.kt)("inlineCode",{parentName:"p"},"UPSERT")," is the default behavior."),(0,o.kt)("p",null,"Associated objects are slightly different, are neither controlled by the save mode API nor support INSERT_ONLY, and the default behavior is UPDATE_ONLY. That is, if the specified associated object does not exist in the database, an exception will be raised."),(0,o.kt)("p",null,"This default behavior is for safety and prevents users from specifying illegal associated objects that do not exist at all."),(0,o.kt)("p",null,"However, sometimes the user does want to specify non-existing association objects and expect the system to automatically insert these non-existing association objects. At this point, the user can do"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"sqlClient\n    .getEntities()\n    .saveCommand(\n        ...object tree of arbitrary complexity, slightly...\n    )\n    .configure(it -> \n        it\n            // highlight-next-line\n            .setAutoAttaching(BookProps.STORE)\n            // highlight-next-line\n            .setAutoAttaching(BookProps.AUTHORS)\n    )\n    .execute();\n"))),(0,o.kt)(s.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"sqlClient\n    .entities\n    .save(\n        ...object tree of arbitrary complexity, slightly...\n    ) {\n        // highlight-next-line\n        setAutoAttaching(Book::store)\n        // highlight-next-line\n        setAutoAttaching(Book::authors)\n    }\n")))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The first ",(0,o.kt)("inlineCode",{parentName:"p"},"setAutoAttaching")," means: if the object associated by the property ",(0,o.kt)("inlineCode",{parentName:"p"},"store")," of the current ",(0,o.kt)("inlineCode",{parentName:"p"},"Book")," object does not exist, insert it automatically.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The second ",(0,o.kt)("inlineCode",{parentName:"p"},"setAutoAttaching")," means: if some element objects in the collection associated by the property ",(0,o.kt)("inlineCode",{parentName:"p"},"authors")," of the current ",(0,o.kt)("inlineCode",{parentName:"p"},"Book")," object do not exist, insert them automatically."))),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"The current ",(0,o.kt)("inlineCode",{parentName:"p"},"Book")," object mentioned here is not the root object, but a ",(0,o.kt)("inlineCode",{parentName:"p"},"Book")," object at any level.")),(0,o.kt)("p",null,"Perhaps, it is cumbersome to configure auto attaching behavior of associations one by one. So jimmer-sql provide a more blind and more convenient API to enable auto attaching for any asscoations."),(0,o.kt)("p",null,"This is the ",(0,o.kt)("inlineCode",{parentName:"p"},"setAutoAttachingAll")," mentioned above"),(0,o.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"sqlClient\n    .getEntities()\n    .saveCommand(\n        ...object tree of arbitrary complexity, slightly...\n    )\n    .configure(it -> it.setAutoAttachingAll())\n    .execute()\n"))),(0,o.kt)(s.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"\nsqlClient\n    .entities\n    .save(\n        ...object tree of arbitrary complexity, slightly...\n    ) {\n        setAutoAttachingAll()\n    }\n\n")))),(0,o.kt)("p",null,"You can understand that, after this configuration, the save mode of any associated object becomes UPSERT."),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"Note: Even if ",(0,o.kt)("inlineCode",{parentName:"p"},"AutoAttaching")," is configured, it is only valid for associated objects with non-id property. Associated objects with only id are still not automatically inserted.")))}h.isMDXComponent=!0},8411:function(e,t,n){t.Z=n.p+"assets/images/save-6631bb52e10864ffe98320a913473282.png"}}]);