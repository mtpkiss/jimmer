"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[2577],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return p}});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,o=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=c(n),p=l,k=m["".concat(s,".").concat(p)]||m[p]||d[p]||o;return n?a.createElement(k,r(r({ref:t},u),{},{components:n})):a.createElement(k,r({ref:t},u))}));function p(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var o=n.length,r=new Array(o);r[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:l,r[1]=i;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},85162:function(e,t,n){n.d(t,{Z:function(){return r}});var a=n(67294),l=n(34334),o="tabItem_Ymn6";function r(e){var t=e.children,n=e.hidden,r=e.className;return a.createElement("div",{role:"tabpanel",className:(0,l.Z)(o,r),hidden:n},t)}},65488:function(e,t,n){n.d(t,{Z:function(){return p}});var a=n(83117),l=n(67294),o=n(34334),r=n(72389),i=n(67392),s=n(7094),c=n(12466),u="tabList__CuJ",d="tabItem_LNqP";function m(e){var t,n,r=e.lazy,m=e.block,p=e.defaultValue,k=e.values,b=e.groupId,h=e.className,g=l.Children.map(e.children,(function(e){if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),y=null!=k?k:g.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),f=(0,i.l)(y,(function(e,t){return e.value===t.value}));if(f.length>0)throw new Error('Docusaurus error: Duplicate values "'+f.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var v=null===p?p:null!=(t=null!=p?p:null==(n=g.find((function(e){return e.props.default})))?void 0:n.props.value)?t:g[0].props.value;if(null!==v&&!y.some((function(e){return e.value===v})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+v+'" but none of its children has the corresponding value. Available values are: '+y.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var T=(0,s.U)(),N=T.tabGroupChoices,w=T.setTabGroupChoices,x=(0,l.useState)(v),j=x[0],S=x[1],B=[],I=(0,c.o5)().blockElementScrollPositionUntilNextRender;if(null!=b){var q=N[b];null!=q&&q!==j&&y.some((function(e){return e.value===q}))&&S(q)}var A=function(e){var t=e.currentTarget,n=B.indexOf(t),a=y[n].value;a!==j&&(I(t),S(a),null!=b&&w(b,String(a)))},C=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a,l=B.indexOf(e.currentTarget)+1;n=null!=(a=B[l])?a:B[0];break;case"ArrowLeft":var o,r=B.indexOf(e.currentTarget)-1;n=null!=(o=B[r])?o:B[B.length-1]}null==(t=n)||t.focus()};return l.createElement("div",{className:(0,o.Z)("tabs-container",u)},l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":m},h)},y.map((function(e){var t=e.value,n=e.label,r=e.attributes;return l.createElement("li",(0,a.Z)({role:"tab",tabIndex:j===t?0:-1,"aria-selected":j===t,key:t,ref:function(e){return B.push(e)},onKeyDown:C,onFocus:A,onClick:A},r,{className:(0,o.Z)("tabs__item",d,null==r?void 0:r.className,{"tabs__item--active":j===t})}),null!=n?n:t)}))),r?(0,l.cloneElement)(g.filter((function(e){return e.props.value===j}))[0],{className:"margin-top--md"}):l.createElement("div",{className:"margin-top--md"},g.map((function(e,t){return(0,l.cloneElement)(e,{key:t,hidden:e.props.value!==j})}))))}function p(e){var t=(0,r.Z)();return l.createElement(m,(0,a.Z)({key:String(t)},e))}},86346:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return u},default:function(){return b},frontMatter:function(){return c},metadata:function(){return d},toc:function(){return p}});var a=n(83117),l=n(80102),o=(n(67294),n(3905)),r=n(65488),i=n(85162),s=["components"],c={sidebar_position:7,title:"jimmer-sql(Old)"},u=void 0,d={unversionedId:"jimmer-sql/index",id:"jimmer-sql/index",title:"jimmer-sql(Old)",description:"This article is copied from the part-ii of Feature list, and the content is exactly the same.",source:"@site/docs/jimmer-sql/index.mdx",sourceDirName:"jimmer-sql",slug:"/jimmer-sql/",permalink:"/jimmer/docs/jimmer-sql/",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer/tree/main/doc/docs/jimmer-sql/index.mdx",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7,title:"jimmer-sql(Old)"},sidebar:"tutorialSidebar",previous:{title:"Validation",permalink:"/jimmer/docs/jimmer-core/validation"},next:{title:"Basic",permalink:"/jimmer/docs/jimmer-sql/basic/"}},m={},p=[{value:"1. Ultimate performance",id:"1-ultimate-performance",level:2},{value:"2. Strong typed SQL DSL",id:"2-strong-typed-sql-dsl",level:2},{value:"3. Mix native SQL",id:"3-mix-native-sql",level:2},{value:"4. <strong>External cache</strong>",id:"4-external-cache",level:2},{value:"5. <strong>Object Fetcher</strong>",id:"5-object-fetcher",level:2},{value:"6. <strong>Save Command</strong>:",id:"6-save-command",level:2},{value:"7. Global filters",id:"7-global-filters",level:2},{value:"8. Trigger",id:"8-trigger",level:2},{value:"9. <strong>Implicit &amp; dynamic table joins</strong>",id:"9-implicit--dynamic-table-joins",level:2},{value:"10. Extremely simple pagination",id:"10-extremely-simple-pagination",level:2},{value:"11. Extreme lightweight.",id:"11-extreme-lightweight",level:2}],k={toc:p};function b(e){var t=e.components,n=(0,l.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},k,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"This article is copied from the part-ii of ",(0,o.kt)("a",{parentName:"p",href:"../intro"},"Feature list"),", and the content is exactly the same."),(0,o.kt)("p",{parentName:"admonition"},"If you have already read the first part-ii of the ",(0,o.kt)("a",{parentName:"p",href:"../intro"},"Feature list"),", you can skip this article and go straight to the more in-depth documentation.")),(0,o.kt)("p",null,"Three aspects should be considered in ORM design: "),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Query."),(0,o.kt)("li",{parentName:"ol"},"Update."),(0,o.kt)("li",{parentName:"ol"},"Cache. ")),(0,o.kt)("p",null,"For jimmer-sql, each aspect is aimed at object trees with arbitrary depth rather than simple objects. "),(0,o.kt)("p",null,"This distinctive design brings convenience unmatched by other popular solutions."),(0,o.kt)("h2",{id:"1-ultimate-performance"},"1. Ultimate performance"),(0,o.kt)("p",null,"Benchmark report is ",(0,o.kt)("a",{parentName:"p",href:"../benchmark"},"here"),", benchmark source code is ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/babyfish-ct/jimmer/tree/main/benchmark"},"here")),(0,o.kt)("h2",{id:"2-strong-typed-sql-dsl"},"2. Strong typed SQL DSL"),(0,o.kt)("p",null,"Check for errors at compile time rather than runtime whenever possible with strong typed SQL DSL like JPA Criteria, QueryDSL, or JOOQ. Kotlin nullsafety would be introduced to SQL for kotlin API."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Quick view"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = BookTable.$;\nAuthorTableEx author = AuthorTableEx.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .where(\n        book.id().in(sqlClient\n            .createSubQuery(author)\n            .where(author.firstName().eq("Alex"))\n            .select(author.books().id())\n        )\n    )\n    .select(book)\n    .execute();\n'))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table.id valueIn subQuery(Author::class) {\n                where(table.firstName eq "Alex")\n                select(table.books.id)\n            }\n        )\n        select(table)\n    }\n    .execute()\n'))))),(0,o.kt)("h2",{id:"3-mix-native-sql"},"3. Mix native SQL"),(0,o.kt)("p",null,"Strongly typed SQL DSL and Native SQL can be mixed without extra restrictions, Using database-specific features is very easy;"),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Quick view"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = BookTable.$;\n\nList<Tuple3<Book, Integer, Integer>> rows = sqlClient\n    .createQuery(book)\n    .select(\n        book,\n        Expression.numeric().sql(\n            Integer.class,\n            "rank() over(order by %e desc)",\n            it -> {\n                it.expression(book.price());\n            }\n        ),\n        Expression.numeric().sql(\n            Integer.class,\n            "rank() over(partition by %e order by %e desc)",\n            it -> {\n                it.expression(book.store().id());\n                it.expression(book.price());\n            }\n        )\n    )\n    .execute();\n'))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val rows = sqlClient\n    .createQuery(Book::class) {\n        select(\n            table,\n            sql(\n                Int::class, \n                "rank() over(order by %e desc)"\n            ) {\n                expression(table.price)\n            },\n            sql(\n                Int::class, \n                "rank() over(partition by %e order by %e desc)"\n            ) {\n                expression(table.store.id)\n                expression(table.price)\n            }\n        )\n    }\n    .execute()\n'))))),(0,o.kt)("h2",{id:"4-external-cache"},"4. ",(0,o.kt)("strong",{parentName:"h2"},"External cache")),(0,o.kt)("p",null,"Work with any external cache. By default, the framework is just a very lightweight and powerful SQL generator without caching. Still, users can attach any external cache"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"No assumptions are made about the user's cache technology selection, developers can choose any cache technology. The framework only manages and coordinates the cache, and does not do cache implementation.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Unlike other ORMs, jimmer supports not only object cache, but also associative cache. The two are combined behind the scenes and can be used with object fetcher and GraphQL."),(0,o.kt)("p",{parentName:"li"},"So, external cache is designed for object trees with arbitrary depth, rather than simple objects."))),(0,o.kt)("p",null,"For high-performance complex data structure queries, the following two tasks will cause a large workload for developers."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Query different data fragments from different caches, and then manually merge them into a whole and return it.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Ensure consistency between cache and database."))),(0,o.kt)("p",null,"In order to relieve the developer from these two heavy tasks, the framework's caching mechanism is designed to be powerful enough and transparent to the developer."),(0,o.kt)("h2",{id:"5-object-fetcher"},"5. ",(0,o.kt)("strong",{parentName:"h2"},"Object Fetcher")),(0,o.kt)("p",null,"Extend the ability of SQL. If a column in the query is an object type, it can be specified as the query format of the object. This format accepts any association depth and breadth and even allows recursively query self-association attributes. It can be considered that SQL has been extended to a capability comparable to GraphQL."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Quick view"),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Simple Fetcher"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .orderBy(book.name())\n    .select(\n        book.fetch(\n            BookFetcher.$\n                .allScalarFields()\n                .store(\n                    BookStoreFetcher.$\n                        .allScalarFields()\n                )\n                .authors(\n                    AuthorFetcher.$\n                        .allScalarFields()\n                )\n        )\n    )\n    .execute();\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        orderBy(table.name)\n        select(\n            table.fetchBy { \n                allScalarFields()\n                store { \n                    allScalarFields()\n                }\n                authors { \n                    allScalarFields()\n                }\n            }\n        )\n    }\n    .execute()\n"))))),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Fetcher With filter"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .orderBy(book.name())\n    .select(\n        book.fetch(\n            BookFetcher.$\n                .allScalarFields()\n                .store(\n                    BookStoreFetcher.$\n                        .allScalarFields()\n                )\n                .authors(\n                    AuthorFetcher.$\n                        .allScalarFields(),\n                    // This filter sorts the associated collection \n                    it -> it.filter(args -> {\n                        args.orderBy(args.getTable().firstName());\n                        args.orderBy(args.getTable().lastName());\n                    })\n                )\n        )\n    )\n    .execute();\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        orderBy(table.name)\n        select(\n            table.fetchBy { \n                allScalarFields()\n                store { \n                    allScalarFields()\n                }\n                authors({\n                    // This filter sorts the associated collection\n                    filter { \n                        orderBy(table.firstName)\n                        orderBy(table.lastName)\n                    }\n                }) { \n                    allScalarFields()\n                }\n            }\n        )\n    }\n    .execute()\n"))))),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Recursively query self-association attributes"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'TreeNodeTable treeNode = TreeNodeTable.$;\n\nList<TreeNode> rootNodes = sqlClient\n    .createQuery(treeNode)\n    .where(treeNode.parent().isNull())\n    .orderBy(treeNode.name())\n    .select(\n        treeNode.fetch(\n            TreeNodeFetcher.$\n                .allScalarFields()\n                .childNodes(\n                    TreeNodeFetcher.$.allScalarFields(),\n                    it -> {\n                        // Recursively query, no matter how deep\n                        it.recursive(args ->\n                            // but exclude some subtrees\n                            !args.getEntity().name().equals("XX")\n                        );\n                        it.filter(args -> {\n                            args.orderBy(args.getTable().name());\n                        });\n                    }\n                )\n        )\n    )\n    .execute();\n'))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val rootNodes = sqlClient\n    .createQuery(TreeNode::class) {\n        where(table.parent.isNull())\n        orderBy(table.name)\n        select(\n            table.fetchBy {\n                allScalarFields()\n                childNodes({\n                    // Recursively query, no matter how deep\n                    recursive {\n                        // but exclude some subtrees\n                        entity.name != "XX"\n                    }\n                    filter { \n                        orderBy(table.name)\n                    }\n                }) { \n                    allScalarFields()\n                }\n            }\n        )\n    }\n    .execute()\n')))))),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"This feature can work with external cache, this very useful, especially when recursively querying self-associative properties.")),(0,o.kt)("h2",{id:"6-save-command"},"6. ",(0,o.kt)("strong",{parentName:"h2"},"Save Command"),":"),(0,o.kt)("p",null,"The data to be saved is no longer a simple object, but an arbitrarily complex object tree. No matter how complex the tree is, the framework takes care of all the internal details and the developers can handle the whole operation with a single statement. This feature is the inverse of the Object Fetcher."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Quick view"),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Save lonely object"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'Book toBeSaved = BookDraft.$.produce(book -> {\n    book\n        .setName("Algorithms")\n        .setEdition(4)\n        .setPrice(new BigDecimal("53.99"));\n});\nBook saved = sqlClient\n    .getEntities()\n    .save(toBeSaved)\n    .getModifiedEntity();\n'))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val toBeSaved = new(Book::class).by {\n    name = "Algorithms"\n    edition = 4\n    price = BigDecimal("53.99")\n}\nval saved = sqlClient\n    .entities\n    .save(toBeSaved)\n    .modifiedEntity\n'))))),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Save shallow object tree"),(0,o.kt)("p",null,"If the associated objects of the saved object only have id, then only the current object and its associations with other objects can be modified (this may cause the middle table to be modified), not the associated objects themselves."),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'Book toBeSaved = BookDraft.$.produce(book -> {\n    book\n        .setName("Algorithms")\n        .setEdition(4)\n        .setPrice(new BigDecimal("53.99"))\n        .applyStore(store -> {\n            store.setId(7883L);\n        })\n        .addIntoAuthors(author -> {\n            author.setId(28756L);\n        })\n        .addIntoAuthors(author -> {\n            author.setId(634L);\n        });\n});\nBook saved = sqlClient\n    .getEntities()\n    .save(toBeSaved)\n    .getModifiedEntity();\n'))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val toBeSaved = new(Book::class).by {\n    name = "Algorithms"\n    edition = 4\n    price = BigDecimal("53.99")\n    store().apply {\n        id = 7833L\n    }\n    authors().addBy {\n        id = 28756L\n    }\n    authors().addBy {\n        id = 634L\n    }\n}\nval saved = sqlClient\n    .entities\n    .save(toBeSaved)\n    .modifiedEntity\n'))))),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Save deep object tree"),(0,o.kt)("p",null,"If the associated objects of the saved object contains non-id properties, then"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Not only the current object and its associations to other objects can be modified (which may cause the intermediate table to be modified), but also the associated objects can be further modified.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The depth of the saved object tree can be unlimited. However, no matter how deep it is, the framework can handle all the details inside it."))),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'Book toBeSaved = BookDraft.$.produce(book -> {\n    book\n        .setName("Algorithms")\n        .setEdition(4)\n        .setPrice(new BigDecimal("53.99"))\n        .applyStore(store -> {\n            store.setName("O\'REILLY");\n        })\n        .addIntoAuthors(author -> {\n            author\n                .setFirstName("Robert")\n                .setLastName("Sedgewick")\n                .setGender(Gender.MALE);\n        })\n        .addIntoAuthors(author -> {\n            author\n                .setFirstName("Kevin")\n                .setLastName("Wayne")\n                .setGender(Gender.MALE);\n        });\n});\nBook saved = sqlClient\n    .getEntities()\n    .saveCommand(toBeSaved)\n    .configure(it -> {\n        // Automatically create non-existing associated objects\n        it.setAutoAttachingAll();\n    })\n    .execute()\n    .getModifiedEntity();\n'))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val toBeSaved = new(Book::class).by { \n    name = "Algorithms"\n    edition = 4\n    price = BigDecimal("53.99")\n    store().apply { \n        name = "O\'REILLY"\n    }\n    authors().addBy { \n        firstName = "Robert"\n        lastName = "Sedgewick"\n        gender = Gender.MALE\n    }\n    authors().addBy { \n        firstName = "Kevin"\n        lastName = "Wayne"\n        gender = Gender.MALE\n    }\n}\nval saved = sqlClient\n    .entities\n    .save(toBeSaved) {\n        // Automatically create non-existing associated objects\n        setAutoAttachingAll()\n    }\n    .modifiedEntity\n')))))),(0,o.kt)("h2",{id:"7-global-filters"},"7. Global filters"),(0,o.kt)("p",null,"Developers can define global filters to isolate SQL query conditions that are generally suitable for business. Automatically applied to all queries instead of manually adding these query conditions to each query."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Quick view"),(0,o.kt)("p",null,"Typical scenarios for global filters: soft delete, multi-tenancy, data row-based data authorization."),(0,o.kt)("p",null,"Here is a brief description of multi-tenancy as an example."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Define global filters"),"If spring is used, the code is as follows:",(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"@Component\npublic class TenantFilter implements Filter<TenantAwareProps> {\n\n    protected final TenantProvider tenantProvider;\n\n    public TenantFilter(TenantProvider tenantProvider) {\n        this.tenantProvider = tenantProvider;\n    }\n\n    @Override\n    public void filter(FilterArgs<TenantAwareProps> args) {\n        String tenant = tenantProvider.get();\n        if (tenant != null) {\n            args.where(args.getTable().tenant().eq(tenant));\n        }\n    }\n}\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Component\nclass TenantFilter(\n    protected val tenantProvider: TenantProvider\n) : KFilter<TenantAware> {\n\n    override fun filter(args: KFilterArgs<TenantAware>) {\n        tenantProvider.tenant?.let {\n            args.apply {\n                where(table.tenant.eq(it))\n            }\n        }\n    }\n}\n")))),(0,o.kt)("p",null,"Here, we suppose"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"TenantAware")," is an abstract type for all entities that need to be divided by tenant ",(0,o.kt)("em",{parentName:"li"}," (the annotation that decorates this type in Jimmer is @MappedSupperClass not @Entity)"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"tenantProvder")," is a simple dependency object whose only function is to resolve the tenant name from the current user information.")),(0,o.kt)("p",null,"Developers need to configure global filters for SqlClient to enable filters. this detail will not be discuessed here, just look at the effect directly.")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"I. Filter aggregate root objects"),(0,o.kt)("p",null,"Assuming that the ",(0,o.kt)("inlineCode",{parentName:"p"},"Book")," entity inherits ",(0,o.kt)("inlineCode",{parentName:"p"},"TenantAware"),", the usage is as follows"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"List<Book> books = sqlClient.getEntities.findAll(Book.class);\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient.entities.findAll(Book::class);\n")))),"Or",(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(book)\n    .execute();\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = SqlClient\n    .createQuery(Book::class) {\n        select(table)\n    }\n    .execute()\n")))),(0,o.kt)("p",null,"The generated SQL is as follows"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.TENANT, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE, \n    tb_1_.STORE_ID \nfrom BOOK as tb_1_\n/* highlight-next-line */ \nwhere tb_1_.TENANT = ?\n")),(0,o.kt)("p",null,"The simplest query is used here, without any query parameters, but the final generated SQL still filters ",(0,o.kt)("inlineCode",{parentName:"p"},"tb_1_.TENANT"),".")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"II. Filter associated objects"),(0,o.kt)("p",null,"Not only aggregate root objects can be filtered, but also associated objects can be filtered."),(0,o.kt)("p",null,"Assuming that the ",(0,o.kt)("inlineCode",{parentName:"p"},"Book")," entity inherits ",(0,o.kt)("inlineCode",{parentName:"p"},"TenantAware"),", the usage is as follows"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"List<Author> authors = sqlClient.getEntities.findAll(\n    AuthorFetcher.$\n        .allScalarFields()\n        // highlight-next-line\n        .books(\n            BookFetcher.$\n                .allScalarFields()\n        )\n);\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient.entities.findAll(\n    newFetcher(Author::class).by {\n        allScalarFields()\n        // highlight-next-line\n        books {\n            allScalarFields()\n        }\n    }\n);\n")))),"Or",(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"AuthorTable author = AuthorTable.$;\nList<Author> authors = sqlClient\n    .createQuery(author)\n    .select(\n        author.fetch(\n            AuthorFetcher.$\n                .allScalarFields()\n                // highlight-next-line\n                .books(\n                    BookFetcher.$\n                        .allScalarFields()\n                )\n        )\n    )\n    .execute();\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val authors = SqlClient\n    .createQuery(Author::class) {\n        select(\n            table.fetchBy {\n                allScalarFields()\n                // highlight-next-line\n                books {\n                    allScalarFields()\n                }\n            }\n        )\n    }\n    .execute()\n")))),(0,o.kt)("p",null,"This will result in the following two SQL statements being generated"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Querty aggragate root objects"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, tb_1_.FIRST_NAME, tb_1_.LAST_NAME, tb_1_.GENDER \nfrom AUTHOR as tb_1_\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Query associated objects"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_2_.AUTHOR_ID, \n    tb_1_.ID, \n    tb_1_.TENANT, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE \nfrom BOOK as tb_1_ \ninner join BOOK_AUTHOR_MAPPING as tb_2_ \n    on tb_1_.ID = tb_2_.BOOK_ID \nwhere \n    tb_2_.AUTHOR_ID in (?, ?, ?, ?, ?) \nand \n    /* highlight-next-line */\n    tb_1_.TENANT = ?\n")))),(0,o.kt)("p",null,"It's not hard to see that an object fetcher is used here. Although the object fetcher does not impose any ",(0,o.kt)("a",{parentName:"p",href:"./query/fetcher#field-filters"},"field-level filters")," on the associated property ",(0,o.kt)("inlineCode",{parentName:"p"},"Author.books"),", the global filter for the ",(0,o.kt)("inlineCode",{parentName:"p"},"Book")," class still takes effect. As a result, the final production SQL still filters tenant information."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"The filtering of associated objects is demonstrated here through ",(0,o.kt)("a",{parentName:"p",href:"./query/fetcher"},"object fetcher"),". In fact, the ",(0,o.kt)("a",{parentName:"p",href:"./spring-graphql"},"GraphQL")," function provided by Jimmer can also use global filters to filter related objects. The effect of the two is the same, so I won't go into details.")))),(0,o.kt)("h2",{id:"8-trigger"},"8. Trigger"),(0,o.kt)("p",null,"Users can monitor database changes through triggers. Triggers can notify not only changes to objects, but also associated changes."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Quick view"),(0,o.kt)("p",null,"Registration processing logic"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'sqlClient.getTriggers().addEntityListener(Book.class, e -> {\n    System.out.println("The object `Book` is changed");\n    System.out.println("\\told: " + e.getOldEntity());\n    System.out.println("\\tnew: " + e.getNewEntity());\n});\nsqlClient.getTriggers().addAssociationListener(BookProps.STORE, e -> {\n    System.out.println("The many-to-one association `Book.store` is changed");\n    System.out.println("\\tbook id: " + e.getSourceId());\n    System.out.println("\\tdetached book store id: " + e.getDetachedTargetId());\n    System.out.println("\\tattached book store id: " + e.getAttachedTargetId());\n});\nsqlClient.getTriggers().addAssociationListener(BookStoreProps.BOOKS, e -> {\n    System.out.println("The one-to-many association `BookStore.books` is changed");\n    System.out.println("\\tbook store id: " + e.getSourceId());\n    System.out.println("\\tdetached book id: " + e.getDetachedTargetId());\n    System.out.println("\\tattached book id: " + e.getAttachedTargetId());\n});\n'))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'sqlClient.triggers.addEntityListener(Book::class) {\n    println("The object `Book` is changed");\n    println("\\told: ${it.oldEntity}");\n    println("\\tnew: ${it.newEntity}");\n}\nsqlClient.triggers.addAssociationListener(Book::store) {\n    println("The many-to-one association `Book.store` is changed");\n    println("\\tbook id: ${it.sourceId}");\n    println("\\tdetached book store id: ${it.detachedTargetId}");\n    println("\\tattached book store id: ${it.attachedTargetId}");\n}\nsqlClient.triggers.addAssociationListener(BookStore::books) {\n    println("The one-to-many association `BookStore.books` is changed");\n    println("\\tbook store id: ${it.sourceId}");\n    println("\\tdetached book id: ${it.detachedTargetId}");\n    println("\\tattached book id: ${it.attachedTargetId}");\n}\n')))),(0,o.kt)("p",null,"The user also has to do a little extra work for the trigger to take effect. this detail will not be discussed here, just look at the effect directly."),(0,o.kt)("p",null,"Modify the foreign key of ",(0,o.kt)("inlineCode",{parentName:"p"},"Book")," whose ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," is 7 in the data."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"update BOOK set STORE_ID = 2 where ID = 7;\n")),(0,o.kt)("p",null,"Here, the foreign key is modified to 2. Assuming that the old value before modification is 1, the following output can be obtained"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'The object `Book` is changed\n    old: {"id":7,"name":"Programming TypeScript","edition":1,"price":47.50,"store":{"id":1}}\n    new: {"id":7,"name":"Programming TypeScript","edition":1,"price":47.50,"store":{"id":2}}\nThe many-to-one association `Book.store` is changed\n    book id: 7\n    detached book store id: 1\n    attached book store id: 2\nThe one-to-many association `BookStore.books` is changed\n    book store id: 1\n    detached book id: 7\n    attached book id: null\nThe one-to-many association `BookStore.books` is changed\n    book store id: 2\n    detached book id: null\n    attached book id: 7\n'))),(0,o.kt)("h2",{id:"9-implicit--dynamic-table-joins"},"9. ",(0,o.kt)("strong",{parentName:"h2"},"Implicit & dynamic table joins")),(0,o.kt)("p",null,"Jimmer's table joins are designed for very complex queries, it have the following features:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Without explicitly creating table joins, the natural fluent property reference path represents complex multi-table joins, such as:"),(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},'where(table.books.authors.company.city.name eq "ChengDu")'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Table joins that are never used are automatically ignored and do not appear in the final SQL.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"For joined associated object, if only its id property is accessed, jimmer will further ignore more unnecessary join. See ",(0,o.kt)("a",{parentName:"p",href:"./basic/table-join#phantom-join"},"Phantom join")," and ",(0,o.kt)("a",{parentName:"p",href:"./basic/table-join#half-join"},"Half join"),".")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Conflicting table joins in different paths will be automatically merged. See ",(0,o.kt)("a",{parentName:"p",href:"./basic/table-join#dynamic-join"},"Dynamic join"),"."))),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Quick view"),(0,o.kt)("p",null,"This example shows automatic merge conflicting table joins."),(0,o.kt)("p",null,"For simplicity, only the simplest two-table joins is demonstrated."),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public List<Book> findBooks(\n    @Nullable String storeName,\n    @Nullable String storeWebsite\n) {\n    BookTable book = BookTable.$;\n    \n    return sqlClient\n        .createQuery(book)\n        .whereIf(\n            storeName != null,\n            () -> book.store().name().like(storeName)\n        )\n        .whereIf(\n            storeWebsite != null,\n            () -> book.store().website().like(storeWebsite)\n        )\n        .select(book)\n        .execute();\n}\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun findBooks(\n    storeName: String?,\n    storeWebsite: String?\n): List<Book> =\n    sqlClient\n        .createQuery(Book::class) {\n            storeName?.let { \n                where(table.store.name like it)\n            }\n            storeWebsite?.let { \n                where(table.store.website like it)\n            }\n            select(table)\n        }\n        .execute()\n")))),(0,o.kt)("p",null,"Taking the above code as an example, ",(0,o.kt)("inlineCode",{parentName:"p"},"book.store()")," in the Java code and ",(0,o.kt)("inlineCode",{parentName:"p"},"table.store")," in the kotlin code represent the inner join of the association ",(0,o.kt)("inlineCode",{parentName:"p"},"Book::store"),"."),(0,o.kt)("p",null,"Obviously, the above code implements a dynamic query, and different parameters will cause different SQL to be generated."),(0,o.kt)("p",null,"When the above two conditions are met, in the final generated SQL, the table join of ",(0,o.kt)("inlineCode",{parentName:"p"},"Book::store")," will only appear once, not twice. ")),(0,o.kt)("h2",{id:"10-extremely-simple-pagination"},"10. Extremely simple pagination"),(0,o.kt)("p",null,"In the paging scenario, developers only need to focus on querying the actual data, and the query on the number of rows is automatically generated and optimized by the framework."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Quick view"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\n// Developers only need to focus on data-query\nConfigurableRootQuery<Book> query = sqlClient\n    .createQuery(book)\n    ... Omit some code logic, including: ...\n    ... 1. Arbitrarily complex dynamic conditions ...\n    ... 2. Arbitrarily complex dynamic sorting ...\n    ... 3. Arbitrarily complex subqueries ...\n    .select(book);\n\n// count-query can be generated and optimized.\nTypedRootQuery<Long> countQuery = query\n    .reselect((q, t) -> \n        q.select(t.count())\n    )\n    .withoutSortingAndPaging();\n\nint rowCount = countQuery.execute().get(0).intValue();\n\n// Query data from 1/3 to 2/3\nList<Book> books = query\n    .limit(/*limit*/ rowCount / 3, /*offset*/ rowCount / 3)\n    .execute();\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"// Developers only need to focus on data-query\nval query = sqlClient\n    .createQuery(Book::class) {\n        ... Omit some code logic, including: ...\n        ... 1. Arbitrarily complex dynamic conditions ...\n        ... 2. Arbitrarily complex dynamic sorting ...\n        ... 3. Arbitrarily complex subqueries ...\n        select(table)\n    }\n\n// count-query can be generated and optimized.\nval countQuery = query\n    .reselect {\n        select(count(table))\n    }\n    .withoutSortingAndPaging()\n\nval rowCount = countQuery.execute()[0]\n\n// Query data from 1/3 to 2/3\nval books = query\n    .limit(limit = rowCount / 3, offset = rowCount / 3)\n    .execute()\n"))))),(0,o.kt)("h2",{id:"11-extreme-lightweight"},"11. Extreme lightweight."),(0,o.kt)("p",null,"No reflection, no dynamic bytecode generation, guarantee to be Graal friendly."))}b.isMDXComponent=!0}}]);