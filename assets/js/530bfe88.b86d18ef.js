"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[1218],{3905:function(e,a,n){n.d(a,{Zo:function(){return m},kt:function(){return k}});var t=n(67294);function l(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function i(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function r(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?i(Object(n),!0).forEach((function(a){l(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function o(e,a){if(null==e)return{};var n,t,l=function(e,a){if(null==e)return{};var n,t,l={},i=Object.keys(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||(l[n]=e[n]);return l}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=t.createContext({}),p=function(e){var a=t.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):r(r({},a),e)),n},m=function(e){var a=p(e.components);return t.createElement(s.Provider,{value:a},e.children)},u={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},c=t.forwardRef((function(e,a){var n=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=p(n),k=l,d=c["".concat(s,".").concat(k)]||c[k]||u[k]||i;return n?t.createElement(d,r(r({ref:a},m),{},{components:n})):t.createElement(d,r({ref:a},m))}));function k(e,a){var n=arguments,l=a&&a.mdxType;if("string"==typeof e||l){var i=n.length,r=new Array(i);r[0]=c;var o={};for(var s in a)hasOwnProperty.call(a,s)&&(o[s]=a[s]);o.originalType=e,o.mdxType="string"==typeof e?e:l,r[1]=o;for(var p=2;p<i;p++)r[p]=n[p];return t.createElement.apply(null,r)}return t.createElement.apply(null,n)}c.displayName="MDXCreateElement"},85162:function(e,a,n){n.d(a,{Z:function(){return r}});var t=n(67294),l=n(34334),i="tabItem_Ymn6";function r(e){var a=e.children,n=e.hidden,r=e.className;return t.createElement("div",{role:"tabpanel",className:(0,l.Z)(i,r),hidden:n},a)}},65488:function(e,a,n){n.d(a,{Z:function(){return k}});var t=n(83117),l=n(67294),i=n(34334),r=n(72389),o=n(67392),s=n(7094),p=n(12466),m="tabList__CuJ",u="tabItem_LNqP";function c(e){var a,n,r=e.lazy,c=e.block,k=e.defaultValue,d=e.values,b=e.groupId,g=e.className,h=l.Children.map(e.children,(function(e){if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),N=null!=d?d:h.map((function(e){var a=e.props;return{value:a.value,label:a.label,attributes:a.attributes}})),v=(0,o.l)(N,(function(e,a){return e.value===a.value}));if(v.length>0)throw new Error('Docusaurus error: Duplicate values "'+v.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var T=null===k?k:null!=(a=null!=k?k:null==(n=h.find((function(e){return e.props.default})))?void 0:n.props.value)?a:h[0].props.value;if(null!==T&&!N.some((function(e){return e.value===T})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+T+'" but none of its children has the corresponding value. Available values are: '+N.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var x=(0,s.U)(),y=x.tabGroupChoices,f=x.setTabGroupChoices,w=(0,l.useState)(T),I=w[0],j=w[1],E=[],C=(0,p.o5)().blockElementScrollPositionUntilNextRender;if(null!=b){var Z=y[b];null!=Z&&Z!==I&&N.some((function(e){return e.value===Z}))&&j(Z)}var S=function(e){var a=e.currentTarget,n=E.indexOf(a),t=N[n].value;t!==I&&(C(a),j(t),null!=b&&f(b,String(t)))},A=function(e){var a,n=null;switch(e.key){case"ArrowRight":var t,l=E.indexOf(e.currentTarget)+1;n=null!=(t=E[l])?t:E[0];break;case"ArrowLeft":var i,r=E.indexOf(e.currentTarget)-1;n=null!=(i=E[r])?i:E[E.length-1]}null==(a=n)||a.focus()};return l.createElement("div",{className:(0,i.Z)("tabs-container",m)},l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":c},g)},N.map((function(e){var a=e.value,n=e.label,r=e.attributes;return l.createElement("li",(0,t.Z)({role:"tab",tabIndex:I===a?0:-1,"aria-selected":I===a,key:a,ref:function(e){return E.push(e)},onKeyDown:A,onFocus:S,onClick:S},r,{className:(0,i.Z)("tabs__item",u,null==r?void 0:r.className,{"tabs__item--active":I===a})}),null!=n?n:a)}))),r?(0,l.cloneElement)(h.filter((function(e){return e.props.value===I}))[0],{className:"margin-top--md"}):l.createElement("div",{className:"margin-top--md"},h.map((function(e,a){return(0,l.cloneElement)(e,{key:a,hidden:e.props.value!==I})}))))}function k(e){var a=(0,r.Z)();return l.createElement(c,(0,t.Z)({key:String(a)},e))}},66869:function(e,a,n){n.r(a),n.d(a,{assets:function(){return c},contentTitle:function(){return m},default:function(){return b},frontMatter:function(){return p},metadata:function(){return u},toc:function(){return k}});var t=n(83117),l=n(80102),i=(n(67294),n(3905)),r=n(65488),o=n(85162),s=["components"],p={sidebar_position:6,title:"Expression"},m=void 0,u={unversionedId:"jimmer-sql/basic/expression",id:"jimmer-sql/basic/expression",title:"Expression",description:"Literal",source:"@site/docs/jimmer-sql/basic/expression.mdx",sourceDirName:"jimmer-sql/basic",slug:"/jimmer-sql/basic/expression",permalink:"/jimmer/docs/jimmer-sql/basic/expression",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer/tree/main/doc/docs/jimmer-sql/basic/expression.mdx",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"Expression"},sidebar:"tutorialSidebar",previous:{title:"Table joins",permalink:"/jimmer/docs/jimmer-sql/basic/table-join"},next:{title:"Query",permalink:"/jimmer/docs/jimmer-sql/query/"}},c={},k=[{value:"Literal",id:"literal",level:2},{value:"Constant",id:"constant",level:2},{value:"Comparison",id:"comparison",level:2},{value:"Like",id:"like",level:2},{value:"case",id:"case",level:3},{value:"Like mode",id:"like-mode",level:3},{value:"Nullity",id:"nullity",level:2},{value:"IN LIST",id:"in-list",level:2},{value:"Single column",id:"single-column",level:3},{value:"Multiple columns",id:"multiple-columns",level:3},{value:"And, Or, Not",id:"and-or-not",level:2},{value:"And",id:"and",level:3},{value:"Or",id:"or",level:3},{value:"Not",id:"not",level:3},{value:"Computation",id:"computation",level:2},{value:"Aggregate",id:"aggregate",level:2},{value:"Coalesce",id:"coalesce",level:2},{value:"Concat",id:"concat",level:2},{value:"Case",id:"case-1",level:2},{value:"Simple case expression",id:"simple-case-expression",level:3},{value:"Ordinary case expression",id:"ordinary-case-expression",level:3},{value:"Native SQL expression",id:"native-sql-expression",level:2},{value:"Type bootstrap for Java",id:"type-bootstrap-for-java",level:2}],d={toc:k};function b(e){var a=e.components,n=(0,l.Z)(e,s);return(0,i.kt)("wrapper",(0,t.Z)({},d,n,{components:a,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"literal"},"Literal"),(0,i.kt)("p",null,"Let's look at an example first ",(0,i.kt)("em",{parentName:"p"},"(This query has no actual business meaning, just for demonstration)")),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = BookTable.$;\n\nList<\n    Tuple5<\n        String,\n        Long,\n        OffsetDateTime,\n        String,\n        Boolean\n    >\n> tuples = sqlClient\n    .createQuery(book)\n    .select(\n        Expression.string().value("String"),\n        Expression.numeric().value(3L),\n        Expression.comparable().value(OffsetDateTime.now()),\n        Expression.any().value("String"),\n        Expression.nullValue(Boolean.class)\n    )\n    .execute();\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val tuples = sqlClient\n    .createQuery(Book::class) {\n        select(\n            value("String"),\n            value(3L),\n            value(OffsetDateTime.now()),\n            value("String"),\n            nullValue(Boolean::class)\n        )\n    }\n    .execute()\n')))),(0,i.kt)("p",null,"The generated SQL is as follows"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select ?, ?, ?, ?, null from BOOK as tb_1_\n")),(0,i.kt)("p",null,"Except for null, all other types of literals become JDBC parameters."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"In this demonstration, it can be seen that the ",(0,i.kt)("inlineCode",{parentName:"p"},"value()")," method accepts many types of parameters."),(0,i.kt)("p",{parentName:"admonition"},"It should be noted that no matter what the ",(0,i.kt)("inlineCode",{parentName:"p"},"value()")," method parameter type is, it cannot be null, otherwise it will cause an exception."),(0,i.kt)("p",{parentName:"admonition"},"To create a literal expression for null, you must use the ",(0,i.kt)("inlineCode",{parentName:"p"},"nullValue()")," method, which requires specifying the expression type.")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"For java, we use the type bootstrap method:"),(0,i.kt)("ol",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ol"},"Expression.string(), for string types."),(0,i.kt)("li",{parentName:"ol"},"Expression.numeric(), for numeric types."),(0,i.kt)("li",{parentName:"ol"},"Expression.comparble(), for comparable types, that is, types inherited from java.lang.Comparable."),(0,i.kt)("li",{parentName:"ol"},"Expression.any(), other types.")),(0,i.kt)("p",{parentName:"admonition"},"Kotlin does not have this problem, its API is unified.")),(0,i.kt)("p",null,"In most cases, developers do not need to manually create literal expressions."),(0,i.kt)("p",null,"Take the equality judgment to be discussed below as an example, this is the relatively cumbersome way"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    book.name().eq(\n        Expression.string().value("Java in Action")\n    )\n);\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    table.name eq value("Java in Action")\n)\n')))),(0,i.kt)("p",null,"It can be replaced by a more convenient way, like this"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().eq("Java in Action"));\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'where(table.name eq "Java in Action")\n')))),(0,i.kt)("p",null,"Other APIs provide overloaded methods to avoid having developers build literal expressions themselves."),(0,i.kt)("p",null,"However, this cannot be done 100%. In rare cases, developers are still required to build literal expressions themselves."),(0,i.kt)("h2",{id:"constant"},"Constant"),(0,i.kt)("p",null,"Constant expressions are highly similar to literal expressions, let's look at the example first ",(0,i.kt)("em",{parentName:"p"},"(this query has no actual business meaning, just for demonstration)")),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<Integer> constants = sqlClient\n    .createQuery(book)\n    .select(\n        // highlight-next-line\n        Expression.constant(1)\n    )\n    .execute();\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"val constants = sqlClient\n    .createQuery(Book::class) {\n        select(\n            // highlight-next-line\n            constant(1)\n        )\n    }\n    .execute()\n")))),(0,i.kt)("p",null,"The generated SQL is as follows"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    /* highlight-next-line */\n    1 \nfrom BOOK as tb_1_\n")),(0,i.kt)("p",null,"It's not hard to see that, unlike literal expressions that always use JDBC parameters, constant expressions directly hardcode the value into the SQL statement."),(0,i.kt)("p",null,"In order to eliminate the problem of injection attacks, constant expressions only support numeric types, which is a hard limit."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Although constant expressions only support numeric types so that there is no need to worry about injection attacks, please don't abuse it."),(0,i.kt)("p",{parentName:"admonition"},"The only reason why constant expressions exist: Some databases support functional index, if there is a numeric constant inside the SQL expression that defines the function index, in order to match such a function index, constant expression can be very useful."),(0,i.kt)("p",{parentName:"admonition"},"If your project doesn't have this scenario, never use constant expressions, you should always use literal expressions."),(0,i.kt)("p",{parentName:"admonition"},"Using constant expressions incorrectly can have serious consequences. Implanting the fickle numbers as constant expressions into SQL will destroy the stability of the SQL string, and eventually lead to a very low cache hit rate of the internal execution plan of the database, affecting performance.")),(0,i.kt)("h2",{id:"comparison"},"Comparison"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Equal to"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().eq("SQL in Action"));\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name eq "SQL in Action")\n'))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Not equal to"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().ne("SQL in Action"));\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name ne "SQL in Action")\n'))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Greater than"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"where(book.price().gt(new BigDecimal(50)));\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"where(table.price gt BigDecimal(50))\n"))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Greater than or equal to"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"where(book.price().ge(new BigDecimal(50)));\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"where(table.price ge BigDecimal(50))\n"))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Less than"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"where(book.price().lt(new BigDecimal(50)));\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"where(table.price lt BigDecimal(50))\n"))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Less than or equal to"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"where(book.price().le(new BigDecimal(50)));\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"where(table.price le BigDecimal(50))\n"))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Between"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"where(\n    book.price().between(\n        new BigDecimal(40), \n        new BigDecimal(50)\n    )\n);\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"where(\n    table.price.between(\n        BigDecimal(40), \n        BigDecimal(50)\n    )\n)\n"))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Not Between"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"where(\n    book.price().notBetween(\n        new BigDecimal(40), \n        new BigDecimal(50)\n    )\n);\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"where(\n    table.price.notBetween(\n        BigDecimal(40), \n        BigDecimal(50)\n    )\n)\n")))))),(0,i.kt)("h2",{id:"like"},"Like"),(0,i.kt)("h3",{id:"case"},"case"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"like: Case sensitive"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().like("Ab"));\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name like "Ab")\n')))),(0,i.kt)("p",{parentName:"li"},"The final generated SQL condition"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"where tb_1_.NAME like ?\n")),(0,i.kt)("p",{parentName:"li"},"Corresponding JDBC parameters: ",(0,i.kt)("inlineCode",{parentName:"p"},"%Ab%"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"ilike: Case insensitive"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().ilike("Ab"));\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name ilike "Ab")\n')))),(0,i.kt)("p",{parentName:"li"},"The final generated SQL condition"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"where lower(tb_1_.NAME) like ?\n")),(0,i.kt)("p",{parentName:"li"},"Corresponding JDBC parameters: ",(0,i.kt)("inlineCode",{parentName:"p"},"%ab%")))),(0,i.kt)("h3",{id:"like-mode"},"Like mode"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"LikeMode.ANYWHERE"),"(Default behavior when not specified): appear anywhere"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().like("Ab", LikeMode.ANYWHERE));\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name.like("Ab", LikeMode.ANYWHERE))\n')))),(0,i.kt)("p",{parentName:"li"},"Corresponding JDBC parameters: ",(0,i.kt)("inlineCode",{parentName:"p"},"'%Ab%'"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"LikeMode.START"),": as a start"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().like("Ab", LikeMode.START));\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name.like("Ab", LikeMode.START))\n')))),(0,i.kt)("p",{parentName:"li"},"Corresponding JDBC parameters: ",(0,i.kt)("inlineCode",{parentName:"p"},"'Ab%'"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"LikeMode.END"),": as an end"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().like("Ab", LikeMode.END));\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name.like("Ab", LikeMode.END))\n')))),(0,i.kt)("p",{parentName:"li"},"Corresponding JDBC parameters: ",(0,i.kt)("inlineCode",{parentName:"p"},"'%Ab'"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"LikeMode.EXACT"),": exact match"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'where(book.name().like("Ab", LikeMode.EXACT));\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name.like("Ab", LikeMode.EXACT))\n')))),(0,i.kt)("p",{parentName:"li"},"Corresponding JDBC parameters: ",(0,i.kt)("inlineCode",{parentName:"p"},"'Ab'")))),(0,i.kt)("h2",{id:"nullity"},"Nullity"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"where(book.store().isNull());\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"where(table.store.isNull())\n")))),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"where(book.store().isNotNull());\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"where(table.store.isNotNull())\n")))),(0,i.kt)("h2",{id:"in-list"},"IN LIST"),(0,i.kt)("h3",{id:"single-column"},"Single column"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    book.name().in(\n        Arrays.asList(\n            "SQL in Action",\n            "Java in Action"\n        )\n    )\n);\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    table.name valueIn listOf(\n        "SQL in Action",\n        "Java in Action"\n    )\n)\n')))),(0,i.kt)("p",null,"Generated SQL condition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"where tb_1_.NAME in (?, ?)\n")),(0,i.kt)("h3",{id:"multiple-columns"},"Multiple columns"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    Expression.tuple(\n        book.name(),\n        book.edition()\n    ).in(\n        Arrays.asList(\n            new Tuple2<>("SQL in Action", 1),\n            new Tuple2<>("SQL in Action", 2),\n            new Tuple2<>("Java in Action", 1),\n            new Tuple2<>("Java in Action", 2)\n        )\n    )\n);\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    tuple(\n        table.name, \n        table.edition\n    ) valueIn listOf(\n        Tuple2("SQL in Action", 1),\n        Tuple2("SQL in Action", 2),\n        Tuple2("Java in Action", 1),\n        Tuple2("Java in Action", 2)\n    )\n)\n')))),(0,i.kt)("p",null,"Generated SQL condition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"where (tb_1_.NAME, tb_1_.EDITION) in (\n    (?, ?), (?, ?), (?, ?), (?, ?)\n)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"In addition to being used with collections, in can also be used with subqueries."),(0,i.kt)("p",{parentName:"admonition"},"This part of the content will be introduced in detail in the related documents of ",(0,i.kt)("a",{parentName:"p",href:"../query/sub-query"},"subquery"),", and this article will not repeat the introduction.")),(0,i.kt)("h2",{id:"and-or-not"},"And, Or, Not"),(0,i.kt)("h3",{id:"and"},"And"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    Predicate.and(\n        book.name().like("Ab"),\n        book.price().ge(new BigDecimal(40)),\n        book.price().lt(new BigDecimal(60))\n    )\n);\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    and(\n        table.name like "Ab",\n        table.price ge BigDecimal(40),\n        table.price lt BigDecimal(60)\n    )\n)\n')))),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Note that if the logical AND expression is directly used as the parameter of the ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," method, the following two equivalent ways are more recommended.")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Using the variadic version of the ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," method"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    book.name().like("Ab"),\n    book.price().ge(new BigDecimal(40)),\n    book.price().lt(new BigDecimal(60))\n);\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    table.name like "Ab",\n    table.price ge BigDecimal(40),\n    table.price lt BigDecimal(60)\n)\n'))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Multiple calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," method"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'q.where(book.name().like("Ab"));\nq.where(book.price().ge(new BigDecimal(40)));\nq.where(book.price().lt(new BigDecimal(60)));\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(table.name like "Ab")\nwhere(table.price ge BigDecimal(40))\nwhere(table.price lt BigDecimal(60))\n')))))),(0,i.kt)("p",null,"Therefore, the direct use of ",(0,i.kt)("inlineCode",{parentName:"p"},"and")," should not be common in actual projects."),(0,i.kt)("h3",{id:"or"},"Or"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    // highlight-next-line\n    Predicate.or(\n        book.name().like("Ab"),\n        book.price().ge(new BigDecimal(40)),\n        book.price().le(new BigDecimal(60))\n    )\n);\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    // highlight-next-line\n    or(\n        table.name like "Ab",\n        table.price ge BigDecimal(40),\n        table.price le BigDecimal(60)\n    )\n)\n')))),(0,i.kt)("h3",{id:"not"},"Not"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'where(\n    book.name().like("Ab").not()\n);\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'where(\n    not(table.name like "Ab")\n);\n')))),(0,i.kt)("p",null,"It is not always necessary to call the ",(0,i.kt)("inlineCode",{parentName:"p"},"not()")," function. Many times there are shortcuts available, such as"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},".eq(value).not()")," can be abbreviated as ",(0,i.kt)("inlineCode",{parentName:"li"},".ne(value)")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},".isNull().not()")," can be abbreviated as ",(0,i.kt)("inlineCode",{parentName:"li"},".isNotNull(value)")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},".exists()")," can be abbreviated as ",(0,i.kt)("inlineCode",{parentName:"li"},".notExists()")," ",(0,i.kt)("em",{parentName:"li"},"(exists will be introduced in ",(0,i.kt)("a",{parentName:"em",href:"../query/sub-query"},"sub-query"),", but will not be introduced in this article)"))),(0,i.kt)("p",null,"Even if the developer explicitly uses ",(0,i.kt)("inlineCode",{parentName:"p"},"not()"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"not")," expression does not necessarily appear in the final SQL, such as"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"where(\n    book.price().ge(new BigDecimal(40)).not()\n);\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"where(\n    not(book.price ge BigDecimal(40))\n)\n")))),(0,i.kt)("p",null,"The actual generated SQL is"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"where tb_1_1.PRICE < ?\n")),(0,i.kt)("p",null,"jimmer-sql tries to avoid using ",(0,i.kt)("inlineCode",{parentName:"p"},"not")," directly in SQL, but anyway, in the end the SQL logic is equivalent to what you want."),(0,i.kt)("h2",{id:"computation"},"Computation"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"+"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"select(book.price().plus(BigDecimal.TWO));\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"select(table.price + BigDecimal.TWO)\n"))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"-"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"select(book.price().minus(BigDecimal.TWO));\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"select(table.price - BigDecimal.TWO)\n"))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"*"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"select(book.price().times(BigDecimal.TWO));\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"select(table.price * BigDecimal.TWO)\n"))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"/")),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"select(book.price().div(BigDecimal.TWO));\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"select(table.price / BigDecimal.TWO)\n"))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"%"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"select(book.price().rem(BigDecimal.TWO));\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"select(table.price % BigDecimal.TWO)\n")))))),(0,i.kt)("h2",{id:"aggregate"},"Aggregate"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = BookTable.$;\n\nList<\n    Tuple6<\n        Long,\n        Long,\n        BigDecimal,\n        BigDecimal,\n        BigDecimal,\n        BigDecimal\n    >\n> tuples = sqlClient\n    .createQuery(book)\n    .select(\n        book.count(),\n        book.id().count(/* disintct */ true),\n        book.price().sum(),\n        book.price().min(),\n        book.price().max(),\n        book.price().avg()\n    )\n    .execute();\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"val tuples = sqlClient\n    .createQuery(Book::class) {\n        select(\n            count(table),\n            count(table.id, distinct = true),\n            sum(table.price),\n            min(table.price),\n            max(table.price),\n            avg(table.price)\n        );\n    }\n    .execute()\n")))),(0,i.kt)("p",null,"The generated SQL is as follows"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    count(tb_1_.ID), \n    count(distinct tb_1_.ID), \n    sum(tb_1_.PRICE), \n    min(tb_1_.PRICE), \n    max(tb_1_.PRICE), \n    avg(tb_1_.PRICE) \nfrom BOOK as tb_1_\n")),(0,i.kt)("h2",{id:"coalesce"},"Coalesce"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"coalesce")," expression returns the first non-null value in a sequence of expressions."),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'BookStoreTable store = BookStoreTable.$;\n\nList<String> results = sqlClient\n    .createQuery(store)\n    .select(\n        store.website() // 1\n            // highlight-next-line\n            .coalesceBuilder()\n            .or(store.name()) // 2\n            .or("Default Value") // 3\n            .build()\n    )\n    .execute();\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"var results = sqlClient\n    .createQuery(BookStore::class) {\n        select(\n            table.website\n                // highlight-next-line\n                .coalesce() // 1\n                .or(table.name) // 2\n                .end()\n        )\n    }\n")))),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"In this example, kotlin code and java code are different. there is no expression ",(0,i.kt)("inlineCode",{parentName:"p"},"3")," in kotlin code."),(0,i.kt)("p",{parentName:"admonition"},"Kotlin-API intorduces null-safety of kotlin to SQL, ",(0,i.kt)("inlineCode",{parentName:"p"},"table.name")," is a non-null field, so kotlin forces us to write ",(0,i.kt)("inlineCode",{parentName:"p"},"end()")," to finish this expression. "),(0,i.kt)("p",{parentName:"admonition"},"That means expression ",(0,i.kt)("inlineCode",{parentName:"p"},"3")," in java code will never be used.")),(0,i.kt)("p",null,"The generated SQL is as follows"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"SQL for java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    /* highlight-next-line */\n    coalesce(\n        tb_1_.WEBSITE, \n        tb_1_.NAME, \n        ?\n    ) \nfrom BOOK_STORE as tb_1_\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"SQL for kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    /* highlight-next-line */\n    coalesce(\n        tb_1_.WEBSITE, \n        tb_1_.NAME\n    ) \nfrom BOOK_STORE as tb_1_\n")))),(0,i.kt)("p",null,"In particular, if the SQL ",(0,i.kt)("inlineCode",{parentName:"p"},"coalesce")," function has only two parameters, that is, the ",(0,i.kt)("inlineCode",{parentName:"p"},"or()")," method will only be called once, there is a shortcut:"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"BookStoreTable store = BookStoreTable.$;\n\nList<String> results = sqlClient\n    .createQuery(store)\n    .select(\n        // highlight-next-line\n        store.website().coalesce(store.name())\n    )\n    .execute();\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"var results = sqlClient\n    .createQuery(BookStore::class) {\n        select(\n            // highlight-next-line\n            table.website.coalesce(table.name)\n        )\n    }\n    .execute()\n")))),(0,i.kt)("p",null,"The generated SQL is as follows"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    /* highlight-next-line */\n    coalesce(tb_1_.WEBSITE, tb_1_.NAME) \nfrom BOOK_STORE as tb_1_\n")),(0,i.kt)("p",null,"In fact, this way is the most common."),(0,i.kt)("h2",{id:"concat"},"Concat"),(0,i.kt)("p",null,"Contact expressions are used for string concatenation."),(0,i.kt)("p",null,"This example uses a space as separator to concat the author's firstName and lastName"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'AuthorTable author = AuthorTable.$;\n\nList<String> results = sqlClient\n    .createQuery(author)\n    .select(\n        author\n            .firstName()\n            // highlight-next-line\n            .concat(\n                Expression.string().value(" "),\n                author.lastName()\n            )\n    )\n    .execute();\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'var fullNames = sqlClient\n    .createQuery(Author::class) {\n        select(\n            // highlight-next-line\n            concat(\n                table.firstName,\n                value(" "),\n                table.lastName\n            )\n        )\n    }\n    .execute()\n')))),(0,i.kt)("p",null,"The generated SQL is as follows"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    /* highlight-next-line */\n    concat(\n        tb_1_.FIRST_NAME, \n        ?, \n        tb_1_.LAST_NAME\n    ) \nfrom AUTHOR as tb_1_\n")),(0,i.kt)("h2",{id:"case-1"},"Case"),(0,i.kt)("p",null,"There are two types of case expressions, simple case and ordinary case"),(0,i.kt)("h3",{id:"simple-case-expression"},"Simple case expression"),(0,i.kt)("p",null,"A simple case expression needs to specify an expression at the beginning, and each subsequent judgment branch specifies an expected value to check whether a target expression of one branch matches an expected value."),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = BookTable.$;\n\nList<String> results = sqlClient\n    .createQuery(book)\n    .select(\n        Expression.string()\n            // highlight-next-line\n            .caseBuilder(book.name())\n            .when("Java in Action", "Matched")\n            .when("SQL in Action", "Matched")\n            .otherwise("Not matched")\n    )\n    .execute();\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val results = sqlClient\n    .createQuery(Book::class) {\n        select(\n            // highlight-next-line\n            case(table.name)\n                .match("Kotlin in Action", "Matched")\n                .match("SQL in Action", "Matched")\n                .otherwise("Not matched")\n        )\n    }\n    .execute()\n')))),(0,i.kt)("p",null,"The generated SQL is as follows"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    /* highlight-next-line */\n    case tb_1_.NAME \n        when ? then ? \n        when ? then ? \n        else ? \n    end \nfrom BOOK as tb_1_\n")),(0,i.kt)("h3",{id:"ordinary-case-expression"},"Ordinary case expression"),(0,i.kt)("p",null,"Ordinary case expressions do not need to specify any parameters at the beginning, but each subsequent judgment branch can specify a logical judgment expression of arbitrary complexity to check whether the branch is matched."),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = BookTable.$;\n\nList<String> results = sqlClient\n    .createQuery(book)\n    .select(\n        Expression.string()\n            // highlight-next-line\n            .caseBuilder()\n            .when(\n                book.price().lt(new BigDecimal(30)),\n                "Cheap"\n            )\n            .when(\n                book.price().gt(new BigDecimal(70)),\n                "Expensive"\n            )\n            .otherwise("Appropriate")\n    )\n    .execute();\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val results = sqlClient\n    .createQuery(Book::class) {\n        select(\n            // highlight-next-line\n            case()\n                .match(table.price lt BigDecimal(30), "Cheap")\n                .match(table.price gt BigDecimal(70), "Expensive")\n                .otherwise("Appropriate")\n        )\n    }\n    .execute()\n')))),(0,i.kt)("p",null,"The generated SQL is as follows"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    /* highlight-next-line */\n    case \n        when tb_1_.PRICE < ? then ? \n        when tb_1_.PRICE > ? then ? \n        else ? \n    end \nfrom BOOK as tb_1_\n")),(0,i.kt)("h2",{id:"native-sql-expression"},"Native SQL expression"),(0,i.kt)("p",null,"NativeSQL expression is an important function. Database products always have unique capabilities, and it is necessary to bring out the unique capabilities of data products."),(0,i.kt)("p",null,"This example demonstrates how to use regular match expression of Oracle and HSQLDB."),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'AuthorTable author = AuthorTable.$;\n\nList<Author> authors = sqlClient\n    .createQuery(author)\n    .where(\n        Predicate.sql(\n            "regexp_like(%e, %v)",\n            it -> it\n                .expression(author.firstName())\n                .value("^Ste(v|ph)en$")\n        )\n    )\n    .select(author)\n    .execute();\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val authors = sqlClient\n    .createQuery(Author::class) {\n        where(\n            // highlight-next-line\n            sql(Boolean::class, "regexp_like(%e, %v)") {\n                expression(table.firstName)\n                value("^Ste(v|ph)en$")\n            }\n        )\n        select(table)\n    }\n    .execute()\n')))),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"For Java, we call ",(0,i.kt)("inlineCode",{parentName:"p"},"Predicate.sql")," to create query conditions based on native SQL. In fact, other expression types also support NativeSQL expressions, there are 5 ",(0,i.kt)("inlineCode",{parentName:"p"},"sql")," functions in total"),(0,i.kt)("ol",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ol"},"Predicate.sql(...)"),(0,i.kt)("li",{parentName:"ol"},"Expression.string().sql(...)"),(0,i.kt)("li",{parentName:"ol"},"Expression.numeric().sql(...)"),(0,i.kt)("li",{parentName:"ol"},"Expression.comparable().sql(...)"),(0,i.kt)("li",{parentName:"ol"},"Expression.any().sql(...)")),(0,i.kt)("p",{parentName:"admonition"},"Kotlin does not have this problem, its API is unified.")),(0,i.kt)("p",null,'The SQL string template can contain the special symbols "%e" and "%v".'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"%e: an expression"),(0,i.kt)("li",{parentName:"ul"},"%v: a value")),(0,i.kt)("p",null,"The second parameter of the ",(0,i.kt)("inlineCode",{parentName:"p"},"sql(...)")," method is optional and is a lambda expression. The parameter of the lambda expression is an object that supports two methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"expression(Expresion<?>)"),': implants an expression that matches "%e" of the SQL template.'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"value(Object)"),': implants a value that matches "%v" of the SQL template.')),(0,i.kt)("p",null,"The generated SQL is as follows"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.FIRST_NAME, \n    tb_1_.LAST_NAME, \n    tb_1_.GENDER \nfrom AUTHOR as tb_1_ \nwhere\n    /* highlight-next-line */\n    regexp_like(tb_1_.FIRST_NAME, ?)\n")),(0,i.kt)("h2",{id:"type-bootstrap-for-java"},"Type bootstrap for Java"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Kotlin does not require this feature, kotin developer can goto next article.")),(0,i.kt)("p",null,"The java code of above examples calls"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Expression.string(), for string types."),(0,i.kt)("li",{parentName:"ol"},"Expression.numeric(), for numeric types."),(0,i.kt)("li",{parentName:"ol"},"Expression.comparable(), for comparable types"),(0,i.kt)("li",{parentName:"ol"},"Expression.any(), for other types.")),(0,i.kt)("p",null,"and"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Predicate.sql(...), for boolean type"),(0,i.kt)("li",{parentName:"ol"},"Expression.string().sql(...), for string types."),(0,i.kt)("li",{parentName:"ol"},"Expression.numeric().sql(...), for numeric types."),(0,i.kt)("li",{parentName:"ol"},"Expression.comparable().sql(...), for comparable types "),(0,i.kt)("li",{parentName:"ol"},"Expression.any().sql(...), for other types")),(0,i.kt)("p",null,"These methods are called type bootstrap methods. Due to the defects of java itself, it is necessary to help the DSL to perform better type inference at the cost of slightly affecting the development experience."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"This section explains the difficulties encountered in SQL DSL design, and the reasons for these type bootstrap methods, independent of the functionality that jimmer-sql wants to expose. Readers who are not interested in this can choose to ignore it.")),(0,i.kt)("p",null,"Strongly typed SQL DSL needs to define an important basic type Expression to represent SQL expression of any type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public interface Expression<T> {\n    ...Public behaviors of any type, slightly...\n}\n")),(0,i.kt)("p",null,"It is clear"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"For ",(0,i.kt)("inlineCode",{parentName:"li"},"Expression<String>"),", we expect to support like, ilike, etc."),(0,i.kt)("li",{parentName:"ul"},"For ",(0,i.kt)("inlineCode",{parentName:"li"},"Expresion<? extends Number>"),", we expect to support plus, minus, etc.")),(0,i.kt)("p",null,"That is, the DSL expects that the behavior exposed by the ",(0,i.kt)("inlineCode",{parentName:"p"},"Expression<T>")," type can vary depending on the generic parameter."),(0,i.kt)("p",null,"This is a very classic question, supported by many languages, and generally speaking, there are two schools of thought"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The genre represented by C++ destroys the unity of types"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename T> class Expression {\npublic:\n    ...Common behaviors...\n};\n\ntemplate <> class Epxression<std::string> {\npublic:\n    ...Common behaviors...\n    Predicate like(const char* pattern) const;\n    Predicate ilike(const char* pattern) const;\n}\n\ntemplate <> class Epxression<int> {\npublic:\n    ...Common behaviors...\n    Expression<int> operator +(const Expression<int> &right) const;\n    Expression<int> operator -(const Expression<int> &right) const;\n}\n")),(0,i.kt)("p",{parentName:"li"},"This feature of C++ is called template specialization. Although it achieves the design goal, different generic parameters will lead to different type definitions and destroy the unity of the type system, so it is unacceptable for a platform such as the JVM that supports reflection based on unified type system. I used C++ as an example just to show that this is actually an ancient requirement.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The genre represented by kotlin maintains the unity of the type"),(0,i.kt)("p",{parentName:"li"},"In order not to break the already defined ",(0,i.kt)("inlineCode",{parentName:"p"},"Expression<T>")," type, kotlin can use extension functions for the same purpose."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"infix fun Expression<String>.like(String pattern): Predicate { ... }\ninfix fun Expression<String>.ilike(String pattern): Predicate { ... }\n\noperator fun <N: Number> Expression<N>.plus(\n    Expression<N> right\n): Expression<N> { ... }\noperator fun <N: Number> Expression<N>.minus(\n    Expression<N> right\n): Expression<N> { ... }\n")))),(0,i.kt)("p",null,"Obviously, such a capability is not available in current java. So, take the next step and use it in conjunction with inheritance"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public interface Expression<T> {\n    ...Common behaviors...\n}\n\npublic interface NumericExpression<\n    N extends Number\n> extends Expression<N> {\n\n    NumericExpression<N> plus(\n        Expression<N> right\n    );\n    NumericExpression<N> minus(\n        Expression<N> right\n    );\n\n    ...\n}\n\npublic interface ComparableExpression<\n    T extends Compariable<T>\n> extends Expression<N> {\n\n    ...\n}\n\npublic interface StringExpression \nextends ComparableExpression<String> {\n\n    Predicate like(String pattern);\n    Predicate ilike(String pattern);\n\n    ...\n}\n")),(0,i.kt)("p",null,"Since the expression type is split from an ",(0,i.kt)("inlineCode",{parentName:"p"},"Expression<T>")," into ",(0,i.kt)("inlineCode",{parentName:"p"},"Expression<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"StringExpression"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"NumericExpression<N>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Comparable<T>"),", the 4 type bootstrap methods appeared."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"interface Expression {\n\n    static StringFactory string() {...}\n\n    static NumericFactory numeric() {...}\n\n    static ComparableFactory comparable() {...}\n\n    static AnyFactory any() {...}\n\n    interface StringFactory {\n\n        StringExpression value(String value);\n\n        ...\n    }\n\n    interface NumericFactory {\n\n        <N extends Number> NumericExpression<N> value(N value);\n\n        ...\n    }\n\n    interface ComparableFactory {\n\n        <T extends Comparable<T>> ComparableExpression<T> value(T value);\n\n        ...\n    }\n\n    interface AnyFactory {\n\n        <T> Expression<T> value(T value);\n\n        ...\n    }\n}\n")),(0,i.kt)("p",null,"The construction API of literal expressions is listed here. Users can guide the type so that different types of literal expressions can perform different subsequent operations."),(0,i.kt)("p",null,"In fact, when designing Java DSL, in order to solve this problem, there is another way: instead of designing ",(0,i.kt)("inlineCode",{parentName:"p"},"like"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"-")," these operations as member methods of ",(0,i.kt)("inlineCode",{parentName:"p"},"Expression<T>"),", they are designed as a methods of the global object, even some static methods."),(0,i.kt)("p",null,"JPA Criteria is designed such a global object, the code snippet is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"package javax.persistence.criteria;\n\npublic interface CriteriaBuilder {\n\n    // For string expressions...\n    Predicate like(Expression<String> x, String pattern);\n\n    // For numeric expressions...\n    <N extends Number> Expression<N> sum(\n        Expression<? extends N> x, \n        Expression<? extends N> y\n    );\n\n    ....\n}\n")),(0,i.kt)("p",null,"This design circumvents this defect of the java language, but the user must obtain this global object when writing any expression (if it is a static method design, static import is required). Then use the methods of this global object to create all expression objects. for example:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},'cb.like(book.get(Book_.name), "a")'),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"cb")," is that global object."),(0,i.kt)("p",null,"Obviously, the method of the object itself is more natural and more convenient:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},'book.name().like("a")')),(0,i.kt)("p",null,"This more natural and convenient way is used in most cases, and type bootstrap method is not used frequently in development. Therefore, in order to provide a convenient design as much as possible under the limited expressive ability of java, after careful consideration and choice, the expression system of jimmer-sql is designed as you see it now."))}b.isMDXComponent=!0}}]);