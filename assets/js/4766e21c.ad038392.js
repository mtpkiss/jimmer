"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[5881],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=u(n),d=l,b=m["".concat(s,".").concat(d)]||m[d]||p[d]||r;return n?a.createElement(b,o(o({ref:t},c),{},{components:n})):a.createElement(b,o({ref:t},c))}));function d(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,o=new Array(r);o[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:l,o[1]=i;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5162:function(e,t,n){n.d(t,{Z:function(){return o}});var a=n(7294),l=n(4334),r="tabItem_Ymn6";function o(e){var t=e.children,n=e.hidden,o=e.className;return a.createElement("div",{role:"tabpanel",className:(0,l.Z)(r,o),hidden:n},t)}},5488:function(e,t,n){n.d(t,{Z:function(){return d}});var a=n(3117),l=n(7294),r=n(4334),o=n(2389),i=n(7392),s=n(7094),u=n(2466),c="tabList__CuJ",p="tabItem_LNqP";function m(e){var t,n,o=e.lazy,m=e.block,d=e.defaultValue,b=e.values,f=e.groupId,h=e.className,k=l.Children.map(e.children,(function(e){if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),v=null!=b?b:k.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),g=(0,i.l)(v,(function(e,t){return e.value===t.value}));if(g.length>0)throw new Error('Docusaurus error: Duplicate values "'+g.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var N=null===d?d:null!=(t=null!=d?d:null==(n=k.find((function(e){return e.props.default})))?void 0:n.props.value)?t:k[0].props.value;if(null!==N&&!v.some((function(e){return e.value===N})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+N+'" but none of its children has the corresponding value. Available values are: '+v.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var y=(0,s.U)(),T=y.tabGroupChoices,_=y.setTabGroupChoices,w=(0,l.useState)(N),j=w[0],C=w[1],O=[],q=(0,u.o5)().blockElementScrollPositionUntilNextRender;if(null!=f){var I=T[f];null!=I&&I!==j&&v.some((function(e){return e.value===I}))&&C(I)}var x=function(e){var t=e.currentTarget,n=O.indexOf(t),a=v[n].value;a!==j&&(q(t),C(a),null!=f&&_(f,String(a)))},A=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a,l=O.indexOf(e.currentTarget)+1;n=null!=(a=O[l])?a:O[0];break;case"ArrowLeft":var r,o=O.indexOf(e.currentTarget)-1;n=null!=(r=O[o])?r:O[O.length-1]}null==(t=n)||t.focus()};return l.createElement("div",{className:(0,r.Z)("tabs-container",c)},l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":m},h)},v.map((function(e){var t=e.value,n=e.label,o=e.attributes;return l.createElement("li",(0,a.Z)({role:"tab",tabIndex:j===t?0:-1,"aria-selected":j===t,key:t,ref:function(e){return O.push(e)},onKeyDown:A,onFocus:x,onClick:x},o,{className:(0,r.Z)("tabs__item",p,null==o?void 0:o.className,{"tabs__item--active":j===t})}),null!=n?n:t)}))),o?(0,l.cloneElement)(k.filter((function(e){return e.props.value===j}))[0],{className:"margin-top--md"}):l.createElement("div",{className:"margin-top--md"},k.map((function(e,t){return(0,l.cloneElement)(e,{key:t,hidden:e.props.value!==j})}))))}function d(e){var t=(0,o.Z)();return l.createElement(m,(0,a.Z)({key:String(t)},e))}},5725:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return c},default:function(){return f},frontMatter:function(){return u},metadata:function(){return p},toc:function(){return d}});var a=n(3117),l=n(102),r=(n(7294),n(3905)),o=n(5488),i=n(5162),s=["components"],u={sidebar_position:1,title:"Update statement"},c=void 0,p={unversionedId:"jimmer-sql/mutation/update-statement",id:"jimmer-sql/mutation/update-statement",title:"Update statement",description:"The scope of this article",source:"@site/docs/jimmer-sql/mutation/update-statement.mdx",sourceDirName:"jimmer-sql/mutation",slug:"/jimmer-sql/mutation/update-statement",permalink:"/jimmer/docs/jimmer-sql/mutation/update-statement",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer/tree/main/doc/docs/jimmer-sql/mutation/update-statement.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Update statement"},sidebar:"tutorialSidebar",previous:{title:"Mutation",permalink:"/jimmer/docs/jimmer-sql/mutation/"},next:{title:"Delete statement",permalink:"/jimmer/docs/jimmer-sql/mutation/delete-statement"}},m={},d=[{value:"The scope of this article",id:"the-scope-of-this-article",level:2},{value:"Basic udage",id:"basic-udage",level:2},{value:"Use table joins",id:"use-table-joins",level:2},{value:"MySql",id:"mysql",level:3},{value:"Postgres",id:"postgres",level:3}],b={toc:d};function f(e){var t=e.components,n=(0,l.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},b,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"the-scope-of-this-article"},"The scope of this article"),(0,r.kt)("p",null,"Jimmer supports ",(0,r.kt)("a",{parentName:"p",href:"../advanced/trigger"},"trigger"),", which is divided into binlog trigger and transaction trigger."),(0,r.kt)("p",null,"Using transaction triggers will cause jimmer's modification operations to generate more and more complete queries to simulate triggers."),(0,r.kt)("p",null,"Several scenarios have been discussed in this article, and the generated SQL will be discussed for each scenario, all on the premise that transaction triggers are not used."),(0,r.kt)("h2",{id:"basic-udage"},"Basic udage"),(0,r.kt)("p",null,"Update statement usage is as follows"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'AuthorTable author = AuthorTable.$;\n\nint affectedRowCount = sqlClient\n    .createUpdate(author)\n    .set(\n        author.firstName(),\n        author.firstName().concat("*")\n    )\n    .where(author.firstName().eq("Dan"))\n    .execute();\nSystem.out.println("Affected row count: " + affectedRowCount);\n'))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val affectedRowCount = sqlClient\n    .createUpdate(Author::class) {\n        set(\n            table.firstName, \n            concat(table.firstName, value("*"))\n        )\n        where(table.firstName eq "Dan")\n    }\n    .execute()\nprintln("Affected row count: $affectedRowCount")\n')))),(0,r.kt)("p",null,"The final generated SQL is as follows"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"update AUTHOR tb_1_ \nset FIRST_NAME = concat(tb_1_.FIRST_NAME, ?) \nwhere tb_1_.FIRST_NAME = ?\n")),(0,r.kt)("h2",{id:"use-table-joins"},"Use table joins"),(0,r.kt)("p",null,"By default, the update statement does not support table join, which results in an exception"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'AuthorTableEx author = AuthorTableEx.$;\n\nint affectedRowCount = sqlClient\n    .createUpdate(author)\n    .set(\n        author.firstName(),\n        author.firstName().concat("*")\n    )\n    .where(\n        author\n            // highlight-next-line\n            .books()\n            .name()\n            .eq("Learning GraphQL")\n    )\n    .execute();\nSystem.out.println("Affected row count: " + affectedRowCount);\n'))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val affectedRowCount = sqlClient\n    .createUpdate(Author::class) {\n        set(\n            table.firstName,\n            concat(table.firstName, value("*"))\n        )\n        where(\n            table\n                // highlight-next-line\n                .books\n                .name \n                eq "Learning GraphQL"\n        )\n    }\n    .execute()\nprintln("Affected row count: $affectedRowCount")\n')))),(0,r.kt)("p",null,"The exception information is as follows"),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Table joins for update statement is forbidden by the current dialect, but there is a join ",(0,r.kt)("inlineCode",{parentName:"p"},"'Author.books'"),".")),(0,r.kt)("p",null,"When using MySql or Postgres, the update statement can use the table joins."),(0,r.kt)("h3",{id:"mysql"},"MySql"),(0,r.kt)("p",null,"First, you need to specify the dialect as MySqlDialect when creating JSqlClient"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"JSqlClient sqlClient = JSqlClient\n    .newBuilder()\n    .setDialect(\n        new org.babyfish.jimmer.sql.dialect.MySqlDialect()\n    )\n    ...\n    .build();\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val sqlClient = newKSqlClient {\n    setDialect(org.babyfish.jimmer.sql.dialect.MySqlDialect())\n}\n")))),(0,r.kt)("p",null,"Then, you can use table joins in the update statement"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'AuthorTableEx author = AuthorTableEx.$;\n\nint affectedRowCount = sqlClient\n    .createUpdate(author)\n    .set(\n        author.firstName(),\n        author.firstName().concat("*")\n    )\n    .set(\n        author.books().name(),\n        author.books().name().concat("*")\n    )\n    .set(\n        author.books().store().name(),\n        author.books().store().name().concat("*")\n    )\n    .where(\n        author.books().store().name().eq("MANNING")\n    )\n    .execute();\nSystem.out.println("Affected row count: " + affectedRowCount);\n'))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val affectedRowCount = sqlClient\n    .createUpdate(Author::class) {\n        set(\n            table.firstName,\n            concat(table.firstName, value("*"))\n        )\n        set(\n            table.books.name,\n            concat(table.books.name, value("*"))\n        )\n        set(\n            table.books.store.name,\n            concat(table.books.store.name, value("*"))\n        )\n        where(\n            table.books.store.name eq "MANNING"\n        )\n    }\n    .execute()\nprintln("Affected row count: $affectedRowCount")\n')))),(0,r.kt)("p",null,"Finally, the SQL statement for MySQL is generated as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"update \n    AUTHOR tb_1_ \n    inner join BOOK_AUTHOR_MAPPING as tb_2_ \n        on tb_1_.ID = tb_2_.AUTHOR_ID \n    inner join BOOK as tb_3_ \n        on tb_2_.BOOK_ID = tb_3_.ID \n    inner join BOOK_STORE as tb_4_ \n        on tb_3_.STORE_ID = tb_4_.ID \nset \n    tb_1_.FIRST_NAME = concat(tb_1_.FIRST_NAME, ?), \n    tb_3_.NAME = concat(tb_3_.NAME, ?), \n    tb_4_.NAME = concat(tb_4_.NAME, ?) \nwhere \n    tb_4_.NAME = ?\n")),(0,r.kt)("h3",{id:"postgres"},"Postgres"),(0,r.kt)("p",null,"First, you need to specify the dialect as PostgresDialect when creating JSqlClient"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"JSqlClient sqlClient = JSqlClient\n    .newBuilder()\n    .setDialect(\n        new org.babyfish.jimmer.sql.dialect.PostgresDialect()\n    )\n    ...\n    .build();\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val sqlClient = newKSqlClient {\n    setDialect(org.babyfish.jimmer.sql.dialect.PostgresDialect())\n}\n")))),(0,r.kt)("p",null,"Then, you can use Table joins in the update statement"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'AuthorTableEx author = AuthorTableEx.$;\n\nint affectedRowCount = sqlClient\n    .createUpdate(author)\n    .set(\n        author.firstName(),\n        author.firstName().concat("*")\n    )\n    .where(\n        author.books().store().name().eq("MANNING")\n    )\n    .execute();\nSystem.out.println("Affected row count: " + affectedRowCount);\n'))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val affectedRowCount = sqlClient\n    .createUpdate(Author::class) {\n        set(\n            table.firstName,\n            concat(table.firstName, value("*"))\n        )\n        where(\n            table.books.store.name eq "MANNING"\n        )\n    }\n    .execute()\nprintln("Affected row count: $affectedRowCount")\n')))),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Unlike MySql, Table joins using update statement in Postgres has the following limitations"),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"You can only use table joins in a ",(0,r.kt)("inlineCode",{parentName:"p"},"where")," clause, not in a ",(0,r.kt)("inlineCode",{parentName:"p"},"set")," clause. That is, postgres still only allows to modify the fields of the primary table, and supports join to other tables only for where condition.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The join path can have multiple levels, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"author.books().store()"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"books()")," is level 1 and ",(0,r.kt)("inlineCode",{parentName:"p"},"store()")," is level 2."),(0,r.kt)("p",{parentName:"li"}," The join type of the first level join must be ",(0,r.kt)("inlineCode",{parentName:"p"},"inner join"),".")))),(0,r.kt)("p",null,"Finally, the SQL statement for Postgres is generated as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"update \n    AUTHOR tb_1_ \nset \n    FIRST_NAME = concat(tb_1_.FIRST_NAME, ?) \nfrom BOOK_AUTHOR_MAPPING as tb_2_ /* \u03b1 */\ninner join BOOK as tb_3_ /* \u03b2 */\n    on tb_2_.BOOK_ID = tb_3_.ID \ninner join BOOK_STORE as tb_4_ /* \u03b3 */\n    on tb_3_.STORE_ID = tb_4_.ID \nwhere \n    tb_1_.ID = tb_2_.AUTHOR_ID /* join codition of \u03b1 */\nand \n    tb_4_.NAME = ?\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The join path ",(0,r.kt)("inlineCode",{parentName:"p"},"author.books().store()")," has 2 levels, ",(0,r.kt)("inlineCode",{parentName:"p"},"books()")," is level 1, ",(0,r.kt)("inlineCode",{parentName:"p"},"store()")," is level 2."),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The first level ",(0,r.kt)("inlineCode",{parentName:"p"},"books()")," involves two tables"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"BOOK_AUTHOR_MAPPING")," table at ",(0,r.kt)("inlineCode",{parentName:"li"},"\u03b1")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"BOOK")," table at ",(0,r.kt)("inlineCode",{parentName:"li"},"\u03b2")))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The second level ",(0,r.kt)("inlineCode",{parentName:"p"},"store()")," involves a table"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"BOOK_STORE")," table at ",(0,r.kt)("inlineCode",{parentName:"li"},"\u03b3"))))),(0,r.kt)("p",{parentName:"admonition"},"In the update statement of postgres, the direct table join from primary table cannot be wrote as ",(0,r.kt)("inlineCode",{parentName:"p"},"join")," + ",(0,r.kt)("inlineCode",{parentName:"p"},"on"),", and must be equivalently converted to ",(0,r.kt)("inlineCode",{parentName:"p"},"from")," + ",(0,r.kt)("inlineCode",{parentName:"p"},"where"),"."),(0,r.kt)("p",{parentName:"admonition"},"This is why jimmer-sql stipulates that the type of the first-level table join of the update statement in the postgres dialect must be ",(0,r.kt)("inlineCode",{parentName:"p"},"inner join"),".")))}f.isMDXComponent=!0}}]);